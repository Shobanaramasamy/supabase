{"ast":null,"code":"import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nimport RealtimePresence from './RealtimePresence';\nexport default class RealtimeChannel {\n  constructor(topic) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let socket = arguments.length > 2 ? arguments[2] : undefined;\n    this.topic = topic;\n    this.params = params;\n    this.socket = socket;\n    this.bindings = [];\n    this.state = CHANNEL_STATES.closed;\n    this.joinedOnce = false;\n    this.pushBuffer = [];\n    this.timeout = this.socket.timeout;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.rejoinTimer = new Timer(() => this.rejoinUntilConnected(), this.socket.reconnectAfterMs);\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined;\n      this.rejoinTimer.reset();\n      this.pushBuffer.forEach(pushEvent => pushEvent.send());\n      this.pushBuffer = [];\n    });\n    this.onClose(() => {\n      this.rejoinTimer.reset();\n      this.socket.log('channel', `close ${this.topic} ${this.joinRef()}`);\n      this.state = CHANNEL_STATES.closed;\n      this.socket.remove(this);\n    });\n    this.onError(reason => {\n      if (this.isLeaving() || this.isClosed()) {\n        return;\n      }\n      this.socket.log('channel', `error ${this.topic}`, reason);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive('timeout', () => {\n      if (!this.isJoining()) {\n        return;\n      }\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this.on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {\n      this.trigger(this.replyEventName(ref), payload);\n    });\n    this.presence = new RealtimePresence(this);\n  }\n  list() {\n    return this.presence.list();\n  }\n  rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout();\n    if (this.socket.isConnected()) {\n      this.rejoin();\n    }\n  }\n  subscribe() {\n    let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n    if (this.joinedOnce) {\n      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;\n    } else {\n      const configs = this.bindings.reduce((acc, binding) => {\n        const {\n          type\n        } = binding;\n        if (!['phx_close', 'phx_error', 'phx_reply', 'presence_diff', 'presence_state'].includes(type)) {\n          acc[type] = binding;\n        }\n        return acc;\n      }, {});\n      if (Object.keys(configs).length) {\n        this.updateJoinPayload({\n          configs\n        });\n      }\n      this.joinedOnce = true;\n      this.rejoin(timeout);\n      return this.joinPush;\n    }\n  }\n  /**\n   * Registers a callback that will be executed when the channel closes.\n   */\n  onClose(callback) {\n    this.on(CHANNEL_EVENTS.close, {}, callback);\n  }\n  /**\n   * Registers a callback that will be executed when the channel encounteres an error.\n   */\n  onError(callback) {\n    this.on(CHANNEL_EVENTS.error, {}, reason => callback(reason));\n  }\n  on(type, filter, callback) {\n    this.bindings.push({\n      type,\n      filter: filter !== null && filter !== void 0 ? filter : {},\n      callback: callback !== null && callback !== void 0 ? callback : () => {}\n    });\n  }\n  off(type, filter) {\n    this.bindings = this.bindings.filter(bind => {\n      return !(bind.type === type && RealtimeChannel.isEqual(bind.filter, filter));\n    });\n  }\n  /**\n   * Returns `true` if the socket is connected and the channel has been joined.\n   */\n  canPush() {\n    return this.socket.isConnected() && this.isJoined();\n  }\n  push(event, payload) {\n    let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.timeout;\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n    }\n    let pushEvent = new Push(this, event, payload, timeout);\n    if (this.canPush()) {\n      pushEvent.send();\n    } else {\n      pushEvent.startTimeout();\n      this.pushBuffer.push(pushEvent);\n    }\n    return pushEvent;\n  }\n  updateJoinPayload(payload) {\n    this.joinPush.updatePayload(payload);\n  }\n  /**\n   * Leaves the channel.\n   *\n   * Unsubscribes from server events, and instructs channel to terminate on server.\n   * Triggers onClose() hooks.\n   *\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n   */\n  unsubscribe() {\n    let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n    this.state = CHANNEL_STATES.leaving;\n    const onClose = () => {\n      this.socket.log('channel', `leave ${this.topic}`);\n      this.trigger(CHANNEL_EVENTS.close, 'leave', this.joinRef());\n    };\n    // Destroy joinPush to avoid connection timeouts during unscription phase\n    this.joinPush.destroy();\n    const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n    leavePush.receive('ok', () => onClose()).receive('timeout', () => onClose());\n    leavePush.send();\n    if (!this.canPush()) {\n      leavePush.trigger('ok', {});\n    }\n    return leavePush;\n  }\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\n   * Must return the payload, modified or unmodified.\n   */\n  onMessage(event, payload, ref) {\n    return payload;\n  }\n  isMember(topic) {\n    return this.topic === topic;\n  }\n  joinRef() {\n    return this.joinPush.ref;\n  }\n  rejoin() {\n    let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n    if (this.isLeaving()) {\n      return;\n    }\n    this.socket.leaveOpenTopic(this.topic);\n    this.state = CHANNEL_STATES.joining;\n    this.joinPush.resend(timeout);\n  }\n  trigger(type, payload, ref) {\n    const {\n      close,\n      error,\n      leave,\n      join\n    } = CHANNEL_EVENTS;\n    const events = [close, error, leave, join];\n    if (ref && events.indexOf(type) >= 0 && ref !== this.joinRef()) {\n      return;\n    }\n    const handledPayload = this.onMessage(type, payload, ref);\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n    }\n    this.bindings.filter(bind => {\n      var _a, _b;\n      return (bind === null || bind === void 0 ? void 0 : bind.type) === type && (((_a = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' || ((_b = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _b === void 0 ? void 0 : _b.event) === (payload === null || payload === void 0 ? void 0 : payload.event));\n    }).map(bind => bind.callback(handledPayload, ref));\n  }\n  send(payload) {\n    const push = this.push(payload.type, payload);\n    return new Promise((resolve, reject) => {\n      push.receive('ok', () => resolve('ok'));\n      push.receive('timeout', () => reject('timeout'));\n    });\n  }\n  replyEventName(ref) {\n    return `chan_reply_${ref}`;\n  }\n  isClosed() {\n    return this.state === CHANNEL_STATES.closed;\n  }\n  isErrored() {\n    return this.state === CHANNEL_STATES.errored;\n  }\n  isJoined() {\n    return this.state === CHANNEL_STATES.joined;\n  }\n  isJoining() {\n    return this.state === CHANNEL_STATES.joining;\n  }\n  isLeaving() {\n    return this.state === CHANNEL_STATES.leaving;\n  }\n  static isEqual(obj1, obj2) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n      return false;\n    }\n    for (const k in obj1) {\n      if (obj1[k] !== obj2[k]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}","map":{"version":3,"names":["CHANNEL_EVENTS","CHANNEL_STATES","Push","Timer","RealtimePresence","RealtimeChannel","constructor","topic","params","arguments","length","undefined","socket","bindings","state","closed","joinedOnce","pushBuffer","timeout","joinPush","join","rejoinTimer","rejoinUntilConnected","reconnectAfterMs","receive","joined","reset","forEach","pushEvent","send","onClose","log","joinRef","remove","onError","reason","isLeaving","isClosed","errored","scheduleTimeout","isJoining","on","reply","payload","ref","trigger","replyEventName","presence","list","isConnected","rejoin","subscribe","configs","reduce","acc","binding","type","includes","Object","keys","updateJoinPayload","callback","close","error","filter","push","off","bind","isEqual","canPush","isJoined","event","startTimeout","updatePayload","unsubscribe","leaving","destroy","leavePush","leave","onMessage","isMember","leaveOpenTopic","joining","resend","events","indexOf","handledPayload","_a","_b","map","Promise","resolve","reject","isErrored","obj1","obj2","k"],"sources":["/Users/mako/Downloads/supabase-todo-main/node_modules/@supabase/realtime-js/src/RealtimeChannel.ts"],"sourcesContent":["import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants'\nimport Push from './lib/push'\nimport RealtimeClient from './RealtimeClient'\nimport Timer from './lib/timer'\nimport RealtimePresence from './RealtimePresence'\n\nexport default class RealtimeChannel {\n  bindings: any[] = []\n  timeout: number\n  state = CHANNEL_STATES.closed\n  joinedOnce = false\n  joinPush: Push\n  rejoinTimer: Timer\n  pushBuffer: Push[] = []\n  presence: RealtimePresence\n\n  constructor(\n    public topic: string,\n    public params: { [key: string]: unknown } = {},\n    public socket: RealtimeClient\n  ) {\n    this.timeout = this.socket.timeout\n    this.joinPush = new Push(\n      this,\n      CHANNEL_EVENTS.join,\n      this.params,\n      this.timeout\n    )\n    this.rejoinTimer = new Timer(\n      () => this.rejoinUntilConnected(),\n      this.socket.reconnectAfterMs\n    )\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined\n      this.rejoinTimer.reset()\n      this.pushBuffer.forEach((pushEvent: Push) => pushEvent.send())\n      this.pushBuffer = []\n    })\n    this.onClose(() => {\n      this.rejoinTimer.reset()\n      this.socket.log('channel', `close ${this.topic} ${this.joinRef()}`)\n      this.state = CHANNEL_STATES.closed\n      this.socket.remove(this)\n    })\n    this.onError((reason: string) => {\n      if (this.isLeaving() || this.isClosed()) {\n        return\n      }\n      this.socket.log('channel', `error ${this.topic}`, reason)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this.joinPush.receive('timeout', () => {\n      if (!this.isJoining()) {\n        return\n      }\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this.on(CHANNEL_EVENTS.reply, {}, (payload: any, ref: string) => {\n      this.trigger(this.replyEventName(ref), payload)\n    })\n    this.presence = new RealtimePresence(this)\n  }\n\n  list() {\n    return this.presence.list()\n  }\n\n  rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout()\n    if (this.socket.isConnected()) {\n      this.rejoin()\n    }\n  }\n\n  subscribe(timeout = this.timeout) {\n    if (this.joinedOnce) {\n      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`\n    } else {\n      const configs = this.bindings.reduce(\n        (acc, binding: { [key: string]: any }) => {\n          const { type } = binding\n          if (\n            ![\n              'phx_close',\n              'phx_error',\n              'phx_reply',\n              'presence_diff',\n              'presence_state',\n            ].includes(type)\n          ) {\n            acc[type] = binding\n          }\n          return acc\n        },\n        {}\n      )\n\n      if (Object.keys(configs).length) {\n        this.updateJoinPayload({ configs })\n      }\n\n      this.joinedOnce = true\n      this.rejoin(timeout)\n      return this.joinPush\n    }\n  }\n\n  /**\n   * Registers a callback that will be executed when the channel closes.\n   */\n  onClose(callback: Function) {\n    this.on(CHANNEL_EVENTS.close, {}, callback)\n  }\n\n  /**\n   * Registers a callback that will be executed when the channel encounteres an error.\n   */\n  onError(callback: Function) {\n    this.on(CHANNEL_EVENTS.error, {}, (reason: string) => callback(reason))\n  }\n\n  on(type: string, filter?: { [key: string]: string }, callback?: Function) {\n    this.bindings.push({\n      type,\n      filter: filter ?? {},\n      callback: callback ?? (() => {}),\n    })\n  }\n\n  off(type: string, filter: { [key: string]: any }) {\n    this.bindings = this.bindings.filter((bind) => {\n      return !(\n        bind.type === type && RealtimeChannel.isEqual(bind.filter, filter)\n      )\n    })\n  }\n\n  /**\n   * Returns `true` if the socket is connected and the channel has been joined.\n   */\n  canPush(): boolean {\n    return this.socket.isConnected() && this.isJoined()\n  }\n\n  push(event: CHANNEL_EVENTS, payload: any, timeout = this.timeout) {\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`\n    }\n    let pushEvent = new Push(this, event, payload, timeout)\n    if (this.canPush()) {\n      pushEvent.send()\n    } else {\n      pushEvent.startTimeout()\n      this.pushBuffer.push(pushEvent)\n    }\n\n    return pushEvent\n  }\n\n  updateJoinPayload(payload: { [key: string]: unknown }): void {\n    this.joinPush.updatePayload(payload)\n  }\n\n  /**\n   * Leaves the channel.\n   *\n   * Unsubscribes from server events, and instructs channel to terminate on server.\n   * Triggers onClose() hooks.\n   *\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n   */\n  unsubscribe(timeout = this.timeout): Push {\n    this.state = CHANNEL_STATES.leaving\n    const onClose = () => {\n      this.socket.log('channel', `leave ${this.topic}`)\n      this.trigger(CHANNEL_EVENTS.close, 'leave', this.joinRef())\n    }\n    // Destroy joinPush to avoid connection timeouts during unscription phase\n    this.joinPush.destroy()\n\n    const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout)\n    leavePush.receive('ok', () => onClose()).receive('timeout', () => onClose())\n    leavePush.send()\n    if (!this.canPush()) {\n      leavePush.trigger('ok', {})\n    }\n\n    return leavePush\n  }\n\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\n   * Must return the payload, modified or unmodified.\n   */\n  onMessage(event: string, payload: any, ref?: string) {\n    return payload\n  }\n\n  isMember(topic: string): boolean {\n    return this.topic === topic\n  }\n\n  joinRef(): string {\n    return this.joinPush.ref\n  }\n\n  rejoin(timeout = this.timeout): void {\n    if (this.isLeaving()) {\n      return\n    }\n    this.socket.leaveOpenTopic(this.topic)\n    this.state = CHANNEL_STATES.joining\n    this.joinPush.resend(timeout)\n  }\n\n  trigger(type: string, payload?: any, ref?: string) {\n    const { close, error, leave, join } = CHANNEL_EVENTS\n    const events: string[] = [close, error, leave, join]\n    if (ref && events.indexOf(type) >= 0 && ref !== this.joinRef()) {\n      return\n    }\n    const handledPayload = this.onMessage(type, payload, ref)\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified'\n    }\n\n    this.bindings\n      .filter((bind) => {\n        return (\n          bind?.type === type &&\n          (bind?.filter?.event === '*' ||\n            bind?.filter?.event === payload?.event)\n        )\n      })\n      .map((bind) => bind.callback(handledPayload, ref))\n  }\n\n  send(payload: { type: string; [key: string]: any }) {\n    const push = this.push(payload.type as any, payload)\n\n    return new Promise((resolve, reject) => {\n      push.receive('ok', () => resolve('ok'))\n      push.receive('timeout', () => reject('timeout'))\n    })\n  }\n\n  replyEventName(ref: string): string {\n    return `chan_reply_${ref}`\n  }\n\n  isClosed(): boolean {\n    return this.state === CHANNEL_STATES.closed\n  }\n  isErrored(): boolean {\n    return this.state === CHANNEL_STATES.errored\n  }\n  isJoined(): boolean {\n    return this.state === CHANNEL_STATES.joined\n  }\n  isJoining(): boolean {\n    return this.state === CHANNEL_STATES.joining\n  }\n  isLeaving(): boolean {\n    return this.state === CHANNEL_STATES.leaving\n  }\n\n  private static isEqual(\n    obj1: { [key: string]: string },\n    obj2: { [key: string]: string }\n  ) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n      return false\n    }\n\n    for (const k in obj1) {\n      if (obj1[k] !== obj2[k]) {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}