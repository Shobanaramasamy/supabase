{"ast":null,"code":"import _classCallCheck from \"/Users/mako/Downloads/todo_supabase/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/mako/Downloads/todo_supabase/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nvar RealtimeSubscription = /*#__PURE__*/function () {\n  function RealtimeSubscription(topic) {\n    var _this = this;\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var socket = arguments.length > 2 ? arguments[2] : undefined;\n    _classCallCheck(this, RealtimeSubscription);\n    this.topic = topic;\n    this.params = params;\n    this.socket = socket;\n    this.bindings = [];\n    this.state = CHANNEL_STATES.closed;\n    this.joinedOnce = false;\n    this.pushBuffer = [];\n    this.timeout = this.socket.timeout;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.rejoinTimer = new Timer(function () {\n      return _this.rejoinUntilConnected();\n    }, this.socket.reconnectAfterMs);\n    this.joinPush.receive('ok', function () {\n      _this.state = CHANNEL_STATES.joined;\n      _this.rejoinTimer.reset();\n      _this.pushBuffer.forEach(function (pushEvent) {\n        return pushEvent.send();\n      });\n      _this.pushBuffer = [];\n    });\n    this.onClose(function () {\n      _this.rejoinTimer.reset();\n      _this.socket.log('channel', \"close \".concat(_this.topic, \" \").concat(_this.joinRef()));\n      _this.state = CHANNEL_STATES.closed;\n      _this.socket.remove(_this);\n    });\n    this.onError(function (reason) {\n      if (_this.isLeaving() || _this.isClosed()) {\n        return;\n      }\n      _this.socket.log('channel', \"error \".concat(_this.topic), reason);\n      _this.state = CHANNEL_STATES.errored;\n      _this.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive('timeout', function () {\n      if (!_this.isJoining()) {\n        return;\n      }\n      _this.socket.log('channel', \"timeout \".concat(_this.topic), _this.joinPush.timeout);\n      _this.state = CHANNEL_STATES.errored;\n      _this.rejoinTimer.scheduleTimeout();\n    });\n    this.on(CHANNEL_EVENTS.reply, function (payload, ref) {\n      _this.trigger(_this.replyEventName(ref), payload);\n    });\n  }\n  _createClass(RealtimeSubscription, [{\n    key: \"rejoinUntilConnected\",\n    value: function rejoinUntilConnected() {\n      this.rejoinTimer.scheduleTimeout();\n      if (this.socket.isConnected()) {\n        this.rejoin();\n      }\n    }\n  }, {\n    key: \"subscribe\",\n    value: function subscribe() {\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n      if (this.joinedOnce) {\n        throw \"tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance\";\n      } else {\n        this.joinedOnce = true;\n        this.rejoin(timeout);\n        return this.joinPush;\n      }\n    }\n  }, {\n    key: \"onClose\",\n    value: function onClose(callback) {\n      this.on(CHANNEL_EVENTS.close, callback);\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(callback) {\n      this.on(CHANNEL_EVENTS.error, function (reason) {\n        return callback(reason);\n      });\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, callback) {\n      this.bindings.push({\n        event: event,\n        callback: callback\n      });\n    }\n  }, {\n    key: \"off\",\n    value: function off(event) {\n      this.bindings = this.bindings.filter(function (bind) {\n        return bind.event !== event;\n      });\n    }\n  }, {\n    key: \"canPush\",\n    value: function canPush() {\n      return this.socket.isConnected() && this.isJoined();\n    }\n  }, {\n    key: \"push\",\n    value: function push(event, payload) {\n      var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.timeout;\n      if (!this.joinedOnce) {\n        throw \"tried to push '\".concat(event, \"' to '\").concat(this.topic, \"' before joining. Use channel.subscribe() before pushing events\");\n      }\n      var pushEvent = new Push(this, event, payload, timeout);\n      if (this.canPush()) {\n        pushEvent.send();\n      } else {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n      }\n      return pushEvent;\n    }\n  }, {\n    key: \"updateJoinPayload\",\n    value: function updateJoinPayload(payload) {\n      this.joinPush.updatePayload(payload);\n    }\n    /**\n     * Leaves the channel\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      var _this2 = this;\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n      this.state = CHANNEL_STATES.leaving;\n      var onClose = function onClose() {\n        _this2.socket.log('channel', \"leave \".concat(_this2.topic));\n        _this2.trigger(CHANNEL_EVENTS.close, 'leave', _this2.joinRef());\n      };\n      // Destroy joinPush to avoid connection timeouts during unscription phase\n      this.joinPush.destroy();\n      var leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n      leavePush.receive('ok', function () {\n        return onClose();\n      }).receive('timeout', function () {\n        return onClose();\n      });\n      leavePush.send();\n      if (!this.canPush()) {\n        leavePush.trigger('ok', {});\n      }\n      return leavePush;\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     */\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(event, payload, ref) {\n      return payload;\n    }\n  }, {\n    key: \"isMember\",\n    value: function isMember(topic) {\n      return this.topic === topic;\n    }\n  }, {\n    key: \"joinRef\",\n    value: function joinRef() {\n      return this.joinPush.ref;\n    }\n  }, {\n    key: \"rejoin\",\n    value: function rejoin() {\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n      if (this.isLeaving()) {\n        return;\n      }\n      this.socket.leaveOpenTopic(this.topic);\n      this.state = CHANNEL_STATES.joining;\n      this.joinPush.resend(timeout);\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(event, payload, ref) {\n      var close = CHANNEL_EVENTS.close,\n        error = CHANNEL_EVENTS.error,\n        leave = CHANNEL_EVENTS.leave,\n        join = CHANNEL_EVENTS.join;\n      var events = [close, error, leave, join];\n      if (ref && events.indexOf(event) >= 0 && ref !== this.joinRef()) {\n        return;\n      }\n      var handledPayload = this.onMessage(event, payload, ref);\n      if (payload && !handledPayload) {\n        throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n      }\n      this.bindings.filter(function (bind) {\n        // Bind all events if the user specifies a wildcard.\n        if (bind.event === '*') {\n          return event === (payload === null || payload === void 0 ? void 0 : payload.type);\n        } else {\n          return bind.event === event;\n        }\n      }).map(function (bind) {\n        return bind.callback(handledPayload, ref);\n      });\n    }\n  }, {\n    key: \"replyEventName\",\n    value: function replyEventName(ref) {\n      return \"chan_reply_\".concat(ref);\n    }\n  }, {\n    key: \"isClosed\",\n    value: function isClosed() {\n      return this.state === CHANNEL_STATES.closed;\n    }\n  }, {\n    key: \"isErrored\",\n    value: function isErrored() {\n      return this.state === CHANNEL_STATES.errored;\n    }\n  }, {\n    key: \"isJoined\",\n    value: function isJoined() {\n      return this.state === CHANNEL_STATES.joined;\n    }\n  }, {\n    key: \"isJoining\",\n    value: function isJoining() {\n      return this.state === CHANNEL_STATES.joining;\n    }\n  }, {\n    key: \"isLeaving\",\n    value: function isLeaving() {\n      return this.state === CHANNEL_STATES.leaving;\n    }\n  }]);\n  return RealtimeSubscription;\n}();\nexport { RealtimeSubscription as default };","map":{"version":3,"names":["CHANNEL_EVENTS","CHANNEL_STATES","Push","Timer","RealtimeSubscription","topic","_this","params","arguments","length","undefined","socket","_classCallCheck","bindings","state","closed","joinedOnce","pushBuffer","timeout","joinPush","join","rejoinTimer","rejoinUntilConnected","reconnectAfterMs","receive","joined","reset","forEach","pushEvent","send","onClose","log","concat","joinRef","remove","onError","reason","isLeaving","isClosed","errored","scheduleTimeout","isJoining","on","reply","payload","ref","trigger","replyEventName","_createClass","key","value","isConnected","rejoin","subscribe","callback","close","error","event","push","off","filter","bind","canPush","isJoined","startTimeout","updateJoinPayload","updatePayload","unsubscribe","_this2","leaving","destroy","leavePush","leave","onMessage","isMember","leaveOpenTopic","joining","resend","events","indexOf","handledPayload","type","map","isErrored","default"],"sources":["/Users/mako/Downloads/todo_supabase/node_modules/@supabase/realtime-js/src/RealtimeSubscription.ts"],"sourcesContent":["import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants'\nimport Push from './lib/push'\nimport RealtimeClient from './RealtimeClient'\nimport Timer from './lib/timer'\n\nexport default class RealtimeSubscription {\n  bindings: any[] = []\n  timeout: number\n  state = CHANNEL_STATES.closed\n  joinedOnce = false\n  joinPush: Push\n  rejoinTimer: Timer\n  pushBuffer: Push[] = []\n\n  constructor(\n    public topic: string,\n    public params: { [key: string]: unknown } = {},\n    public socket: RealtimeClient\n  ) {\n    this.timeout = this.socket.timeout\n    this.joinPush = new Push(\n      this,\n      CHANNEL_EVENTS.join,\n      this.params,\n      this.timeout\n    )\n    this.rejoinTimer = new Timer(\n      () => this.rejoinUntilConnected(),\n      this.socket.reconnectAfterMs\n    )\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined\n      this.rejoinTimer.reset()\n      this.pushBuffer.forEach((pushEvent: Push) => pushEvent.send())\n      this.pushBuffer = []\n    })\n    this.onClose(() => {\n      this.rejoinTimer.reset()\n      this.socket.log('channel', `close ${this.topic} ${this.joinRef()}`)\n      this.state = CHANNEL_STATES.closed\n      this.socket.remove(this)\n    })\n    this.onError((reason: string) => {\n      if (this.isLeaving() || this.isClosed()) {\n        return\n      }\n      this.socket.log('channel', `error ${this.topic}`, reason)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this.joinPush.receive('timeout', () => {\n      if (!this.isJoining()) {\n        return\n      }\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this.on(CHANNEL_EVENTS.reply, (payload: any, ref: string) => {\n      this.trigger(this.replyEventName(ref), payload)\n    })\n  }\n\n  rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout()\n    if (this.socket.isConnected()) {\n      this.rejoin()\n    }\n  }\n\n  subscribe(timeout = this.timeout) {\n    if (this.joinedOnce) {\n      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`\n    } else {\n      this.joinedOnce = true\n      this.rejoin(timeout)\n      return this.joinPush\n    }\n  }\n\n  onClose(callback: Function) {\n    this.on(CHANNEL_EVENTS.close, callback)\n  }\n\n  onError(callback: Function) {\n    this.on(CHANNEL_EVENTS.error, (reason: string) => callback(reason))\n  }\n\n  on(event: string, callback: Function) {\n    this.bindings.push({ event, callback })\n  }\n\n  off(event: string) {\n    this.bindings = this.bindings.filter((bind) => bind.event !== event)\n  }\n\n  canPush() {\n    return this.socket.isConnected() && this.isJoined()\n  }\n\n  push(event: CHANNEL_EVENTS, payload: any, timeout = this.timeout) {\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`\n    }\n    let pushEvent = new Push(this, event, payload, timeout)\n    if (this.canPush()) {\n      pushEvent.send()\n    } else {\n      pushEvent.startTimeout()\n      this.pushBuffer.push(pushEvent)\n    }\n\n    return pushEvent\n  }\n\n  updateJoinPayload(payload: { [key: string]: unknown }): void {\n    this.joinPush.updatePayload(payload)\n  }\n\n  /**\n   * Leaves the channel\n   *\n   * Unsubscribes from server events, and instructs channel to terminate on server.\n   * Triggers onClose() hooks.\n   *\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n   */\n  unsubscribe(timeout = this.timeout) {\n    this.state = CHANNEL_STATES.leaving\n    let onClose = () => {\n      this.socket.log('channel', `leave ${this.topic}`)\n      this.trigger(CHANNEL_EVENTS.close, 'leave', this.joinRef())\n    }\n    // Destroy joinPush to avoid connection timeouts during unscription phase\n    this.joinPush.destroy()\n\n    let leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout)\n    leavePush.receive('ok', () => onClose()).receive('timeout', () => onClose())\n    leavePush.send()\n    if (!this.canPush()) {\n      leavePush.trigger('ok', {})\n    }\n\n    return leavePush\n  }\n\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\n   * Must return the payload, modified or unmodified.\n   */\n  onMessage(event: string, payload: any, ref?: string) {\n    return payload\n  }\n\n  isMember(topic: string) {\n    return this.topic === topic\n  }\n\n  joinRef() {\n    return this.joinPush.ref\n  }\n\n  rejoin(timeout = this.timeout) {\n    if (this.isLeaving()) {\n      return\n    }\n    this.socket.leaveOpenTopic(this.topic)\n    this.state = CHANNEL_STATES.joining\n    this.joinPush.resend(timeout)\n  }\n\n  trigger(event: string, payload?: any, ref?: string) {\n    let { close, error, leave, join } = CHANNEL_EVENTS\n    let events: string[] = [close, error, leave, join]\n    if (ref && events.indexOf(event) >= 0 && ref !== this.joinRef()) {\n      return\n    }\n    let handledPayload = this.onMessage(event, payload, ref)\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified'\n    }\n\n    this.bindings\n      .filter((bind) => {\n        // Bind all events if the user specifies a wildcard.\n        if (bind.event === '*') {\n          return event === payload?.type\n        } else {\n          return bind.event === event\n        }\n      })\n      .map((bind) => bind.callback(handledPayload, ref))\n  }\n\n  replyEventName(ref: string) {\n    return `chan_reply_${ref}`\n  }\n\n  isClosed() {\n    return this.state === CHANNEL_STATES.closed\n  }\n  isErrored() {\n    return this.state === CHANNEL_STATES.errored\n  }\n  isJoined() {\n    return this.state === CHANNEL_STATES.joined\n  }\n  isJoining() {\n    return this.state === CHANNEL_STATES.joining\n  }\n  isLeaving() {\n    return this.state === CHANNEL_STATES.leaving\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}