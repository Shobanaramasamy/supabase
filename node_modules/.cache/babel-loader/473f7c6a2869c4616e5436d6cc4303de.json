{"ast":null,"code":"import _regeneratorRuntime from \"/Users/mako/Downloads/todo_supabase/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"/Users/mako/Downloads/todo_supabase/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/mako/Downloads/todo_supabase/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { w3cwebsocket } from 'websocket';\nimport { VSN, CHANNEL_EVENTS, TRANSPORTS, SOCKET_STATES, DEFAULT_TIMEOUT, WS_CLOSE_NORMAL, DEFAULT_HEADERS, CONNECTION_STATE } from './lib/constants';\nimport Timer from './lib/timer';\nimport Serializer from './lib/serializer';\nimport RealtimeSubscription from './RealtimeSubscription';\nvar noop = function noop() {};\nvar RealtimeClient = /*#__PURE__*/function () {\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.longpollerTimeout The maximum timeout of a long poll AJAX request. Defaults to 20s (double the server long poll timer).\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   */\n  function RealtimeClient(endPoint, options) {\n    var _this = this;\n    _classCallCheck(this, RealtimeClient);\n    this.accessToken = null;\n    this.channels = [];\n    this.endPoint = '';\n    this.headers = DEFAULT_HEADERS;\n    this.params = {};\n    this.timeout = DEFAULT_TIMEOUT;\n    this.transport = w3cwebsocket;\n    this.heartbeatIntervalMs = 30000;\n    this.longpollerTimeout = 20000;\n    this.heartbeatTimer = undefined;\n    this.pendingHeartbeatRef = null;\n    this.ref = 0;\n    this.logger = noop;\n    this.conn = null;\n    this.sendBuffer = [];\n    this.serializer = new Serializer();\n    this.stateChangeCallbacks = {\n      open: [],\n      close: [],\n      error: [],\n      message: []\n    };\n    this.endPoint = \"\".concat(endPoint, \"/\").concat(TRANSPORTS.websocket);\n    if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n    if (options === null || options === void 0 ? void 0 : options.headers) this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n    if (options === null || options === void 0 ? void 0 : options.timeout) this.timeout = options.timeout;\n    if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n    if (options === null || options === void 0 ? void 0 : options.transport) this.transport = options.transport;\n    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n    if (options === null || options === void 0 ? void 0 : options.longpollerTimeout) this.longpollerTimeout = options.longpollerTimeout;\n    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : function (tries) {\n      return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n    };\n    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : function (payload, callback) {\n      return callback(JSON.stringify(payload));\n    };\n    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);\n    this.reconnectTimer = new Timer(function () {\n      return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.disconnect();\n              case 2:\n                this.connect();\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }, this.reconnectAfterMs);\n  }\n  /**\n   * Connects the socket, unless already connected.\n   */\n  _createClass(RealtimeClient, [{\n    key: \"connect\",\n    value: function connect() {\n      var _this2 = this;\n      if (this.conn) {\n        return;\n      }\n      this.conn = new this.transport(this.endPointURL(), [], null, this.headers);\n      if (this.conn) {\n        // this.conn.timeout = this.longpollerTimeout // TYPE ERROR\n        this.conn.binaryType = 'arraybuffer';\n        this.conn.onopen = function () {\n          return _this2._onConnOpen();\n        };\n        this.conn.onerror = function (error) {\n          return _this2._onConnError(error);\n        };\n        this.conn.onmessage = function (event) {\n          return _this2.onConnMessage(event);\n        };\n        this.conn.onclose = function (event) {\n          return _this2._onConnClose(event);\n        };\n      }\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */\n  }, {\n    key: \"disconnect\",\n    value: function disconnect(code, reason) {\n      var _this3 = this;\n      return new Promise(function (resolve, _reject) {\n        try {\n          if (_this3.conn) {\n            _this3.conn.onclose = function () {}; // noop\n            if (code) {\n              _this3.conn.close(code, reason || '');\n            } else {\n              _this3.conn.close();\n            }\n            _this3.conn = null;\n            // remove open handles\n            _this3.heartbeatTimer && clearInterval(_this3.heartbeatTimer);\n            _this3.reconnectTimer.reset();\n          }\n          resolve({\n            error: null,\n            data: true\n          });\n        } catch (error) {\n          resolve({\n            error: error,\n            data: false\n          });\n        }\n      });\n    }\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overriden.\n     */\n  }, {\n    key: \"log\",\n    value: function log(kind, msg, data) {\n      this.logger(kind, msg, data);\n    }\n    /**\n     * Registers a callback for connection state change event.\n     *\n     * @param callback A function to be called when the event occurs.\n     *\n     * @example\n     *    socket.onOpen(() => console.log(\"Socket opened.\"))\n     */\n  }, {\n    key: \"onOpen\",\n    value: function onOpen(callback) {\n      this.stateChangeCallbacks.open.push(callback);\n    }\n    /**\n     * Registers a callback for connection state change events.\n     *\n     * @param callback A function to be called when the event occurs.\n     *\n     * @example\n     *    socket.onOpen(() => console.log(\"Socket closed.\"))\n     */\n  }, {\n    key: \"onClose\",\n    value: function onClose(callback) {\n      this.stateChangeCallbacks.close.push(callback);\n    }\n    /**\n     * Registers a callback for connection state change events.\n     *\n     * @param callback A function to be called when the event occurs.\n     *\n     * @example\n     *    socket.onOpen((error) => console.log(\"An error occurred\"))\n     */\n  }, {\n    key: \"onError\",\n    value: function onError(callback) {\n      this.stateChangeCallbacks.error.push(callback);\n    }\n    /**\n     * Calls a function any time a message is received.\n     *\n     * @param callback A function to be called when the event occurs.\n     *\n     * @example\n     *    socket.onMessage((message) => console.log(message))\n     */\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(callback) {\n      this.stateChangeCallbacks.message.push(callback);\n    }\n    /**\n     * Returns the current state of the socket.\n     */\n  }, {\n    key: \"connectionState\",\n    value: function connectionState() {\n      switch (this.conn && this.conn.readyState) {\n        case SOCKET_STATES.connecting:\n          return CONNECTION_STATE.Connecting;\n        case SOCKET_STATES.open:\n          return CONNECTION_STATE.Open;\n        case SOCKET_STATES.closing:\n          return CONNECTION_STATE.Closing;\n        default:\n          return CONNECTION_STATE.Closed;\n      }\n    }\n    /**\n     * Retuns `true` is the connection is open.\n     */\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.connectionState() === CONNECTION_STATE.Open;\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(channel) {\n      this.channels = this.channels.filter(function (c) {\n        return c.joinRef() !== channel.joinRef();\n      });\n    }\n  }, {\n    key: \"channel\",\n    value: function channel(topic) {\n      var chanParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var chan = new RealtimeSubscription(topic, chanParams, this);\n      this.channels.push(chan);\n      return chan;\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */\n  }, {\n    key: \"push\",\n    value: function push(data) {\n      var _this4 = this;\n      var topic = data.topic,\n        event = data.event,\n        payload = data.payload,\n        ref = data.ref;\n      var callback = function callback() {\n        _this4.encode(data, function (result) {\n          var _a;\n          (_a = _this4.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n        });\n      };\n      this.log('push', \"\".concat(topic, \" \").concat(event, \" (\").concat(ref, \")\"), payload);\n      if (this.isConnected()) {\n        callback();\n      } else {\n        this.sendBuffer.push(callback);\n      }\n    }\n  }, {\n    key: \"onConnMessage\",\n    value: function onConnMessage(rawMessage) {\n      var _this5 = this;\n      this.decode(rawMessage.data, function (msg) {\n        var topic = msg.topic,\n          event = msg.event,\n          payload = msg.payload,\n          ref = msg.ref;\n        if (ref && ref === _this5.pendingHeartbeatRef || event === (payload === null || payload === void 0 ? void 0 : payload.type)) {\n          _this5.pendingHeartbeatRef = null;\n        }\n        _this5.log('receive', \"\".concat(payload.status || '', \" \").concat(topic, \" \").concat(event, \" \").concat(ref && '(' + ref + ')' || ''), payload);\n        _this5.channels.filter(function (channel) {\n          return channel.isMember(topic);\n        }).forEach(function (channel) {\n          return channel.trigger(event, payload, ref);\n        });\n        _this5.stateChangeCallbacks.message.forEach(function (callback) {\n          return callback(msg);\n        });\n      });\n    }\n    /**\n     * Returns the URL of the websocket.\n     */\n  }, {\n    key: \"endPointURL\",\n    value: function endPointURL() {\n      return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n        vsn: VSN\n      }));\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     */\n  }, {\n    key: \"makeRef\",\n    value: function makeRef() {\n      var newRef = this.ref + 1;\n      if (newRef === this.ref) {\n        this.ref = 0;\n      } else {\n        this.ref = newRef;\n      }\n      return this.ref.toString();\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * @param token A JWT string.\n     */\n  }, {\n    key: \"setAuth\",\n    value: function setAuth(token) {\n      this.accessToken = token;\n      this.channels.forEach(function (channel) {\n        token && channel.updateJoinPayload({\n          user_token: token\n        });\n        if (channel.joinedOnce && channel.isJoined()) {\n          channel.push(CHANNEL_EVENTS.access_token, {\n            access_token: token\n          });\n        }\n      });\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     */\n  }, {\n    key: \"leaveOpenTopic\",\n    value: function leaveOpenTopic(topic) {\n      var dupChannel = this.channels.find(function (c) {\n        return c.topic === topic && (c.isJoined() || c.isJoining());\n      });\n      if (dupChannel) {\n        this.log('transport', \"leaving duplicate topic \\\"\".concat(topic, \"\\\"\"));\n        dupChannel.unsubscribe();\n      }\n    }\n  }, {\n    key: \"_onConnOpen\",\n    value: function _onConnOpen() {\n      var _this6 = this;\n      this.log('transport', \"connected to \".concat(this.endPointURL()));\n      this._flushSendBuffer();\n      this.reconnectTimer.reset();\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.heartbeatTimer = setInterval(function () {\n        return _this6._sendHeartbeat();\n      }, this.heartbeatIntervalMs);\n      this.stateChangeCallbacks.open.forEach(function (callback) {\n        return callback();\n      });\n    }\n  }, {\n    key: \"_onConnClose\",\n    value: function _onConnClose(event) {\n      this.log('transport', 'close', event);\n      this._triggerChanError();\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.reconnectTimer.scheduleTimeout();\n      this.stateChangeCallbacks.close.forEach(function (callback) {\n        return callback(event);\n      });\n    }\n  }, {\n    key: \"_onConnError\",\n    value: function _onConnError(error) {\n      this.log('transport', error.message);\n      this._triggerChanError();\n      this.stateChangeCallbacks.error.forEach(function (callback) {\n        return callback(error);\n      });\n    }\n  }, {\n    key: \"_triggerChanError\",\n    value: function _triggerChanError() {\n      this.channels.forEach(function (channel) {\n        return channel.trigger(CHANNEL_EVENTS.error);\n      });\n    }\n  }, {\n    key: \"_appendParams\",\n    value: function _appendParams(url, params) {\n      if (Object.keys(params).length === 0) {\n        return url;\n      }\n      var prefix = url.match(/\\?/) ? '&' : '?';\n      var query = new URLSearchParams(params);\n      return \"\".concat(url).concat(prefix).concat(query);\n    }\n  }, {\n    key: \"_flushSendBuffer\",\n    value: function _flushSendBuffer() {\n      if (this.isConnected() && this.sendBuffer.length > 0) {\n        this.sendBuffer.forEach(function (callback) {\n          return callback();\n        });\n        this.sendBuffer = [];\n      }\n    }\n  }, {\n    key: \"_sendHeartbeat\",\n    value: function _sendHeartbeat() {\n      var _a;\n      if (!this.isConnected()) {\n        return;\n      }\n      if (this.pendingHeartbeatRef) {\n        this.pendingHeartbeatRef = null;\n        this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n        (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n        return;\n      }\n      this.pendingHeartbeatRef = this.makeRef();\n      this.push({\n        topic: 'phoenix',\n        event: 'heartbeat',\n        payload: {},\n        ref: this.pendingHeartbeatRef\n      });\n      this.setAuth(this.accessToken);\n    }\n  }]);\n  return RealtimeClient;\n}();\nexport { RealtimeClient as default };","map":{"version":3,"names":["w3cwebsocket","VSN","CHANNEL_EVENTS","TRANSPORTS","SOCKET_STATES","DEFAULT_TIMEOUT","WS_CLOSE_NORMAL","DEFAULT_HEADERS","CONNECTION_STATE","Timer","Serializer","RealtimeSubscription","noop","RealtimeClient","endPoint","options","_this","_classCallCheck","accessToken","channels","headers","params","timeout","transport","heartbeatIntervalMs","longpollerTimeout","heartbeatTimer","undefined","pendingHeartbeatRef","ref","logger","conn","sendBuffer","serializer","stateChangeCallbacks","open","close","error","message","concat","websocket","Object","assign","reconnectAfterMs","tries","encode","payload","callback","JSON","stringify","decode","bind","reconnectTimer","__awaiter","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","disconnect","connect","stop","_createClass","key","value","_this2","endPointURL","binaryType","onopen","_onConnOpen","onerror","_onConnError","onmessage","event","onConnMessage","onclose","_onConnClose","code","reason","_this3","Promise","resolve","_reject","clearInterval","reset","data","log","kind","msg","onOpen","push","onClose","onError","onMessage","connectionState","readyState","connecting","Connecting","Open","closing","Closing","Closed","isConnected","remove","channel","filter","c","joinRef","topic","chanParams","arguments","length","chan","_this4","result","_a","send","rawMessage","_this5","type","status","isMember","forEach","trigger","_appendParams","vsn","makeRef","newRef","toString","setAuth","token","updateJoinPayload","user_token","joinedOnce","isJoined","access_token","leaveOpenTopic","dupChannel","find","isJoining","unsubscribe","_this6","_flushSendBuffer","setInterval","_sendHeartbeat","_triggerChanError","scheduleTimeout","url","keys","prefix","match","query","URLSearchParams","default"],"sources":["/Users/mako/Downloads/todo_supabase/node_modules/@supabase/realtime-js/src/RealtimeClient.ts"],"sourcesContent":["import { w3cwebsocket } from 'websocket'\nimport {\n  VSN,\n  CHANNEL_EVENTS,\n  TRANSPORTS,\n  SOCKET_STATES,\n  DEFAULT_TIMEOUT,\n  WS_CLOSE_NORMAL,\n  DEFAULT_HEADERS,\n  CONNECTION_STATE,\n} from './lib/constants'\nimport Timer from './lib/timer'\nimport Serializer from './lib/serializer'\nimport RealtimeSubscription from './RealtimeSubscription'\n\nexport type Options = {\n  transport?: WebSocket\n  timeout?: number\n  heartbeatIntervalMs?: number\n  longpollerTimeout?: number\n  logger?: Function\n  encode?: Function\n  decode?: Function\n  reconnectAfterMs?: Function\n  headers?: { [key: string]: string }\n  params?: { [key: string]: string }\n}\ntype Message = {\n  topic: string\n  event: string\n  payload: any\n  ref: string\n  join_ref?: string\n}\n\ntype ChannelParams = {\n  selfBroadcast?: boolean\n  [key: string]: any\n}\n\nconst noop = () => {}\n\nexport default class RealtimeClient {\n  accessToken: string | null = null\n  channels: RealtimeSubscription[] = []\n  endPoint: string = ''\n  headers?: { [key: string]: string } = DEFAULT_HEADERS\n  params?: { [key: string]: string } = {}\n  timeout: number = DEFAULT_TIMEOUT\n  transport: any = w3cwebsocket\n  heartbeatIntervalMs: number = 30000\n  longpollerTimeout: number = 20000\n  heartbeatTimer: ReturnType<typeof setInterval> | undefined = undefined\n  pendingHeartbeatRef: string | null = null\n  ref: number = 0\n  reconnectTimer: Timer\n  logger: Function = noop\n  encode: Function\n  decode: Function\n  reconnectAfterMs: Function\n  conn: WebSocket | null = null\n  sendBuffer: Function[] = []\n  serializer: Serializer = new Serializer()\n  stateChangeCallbacks: {\n    open: Function[]\n    close: Function[]\n    error: Function[]\n    message: Function[]\n  } = {\n    open: [],\n    close: [],\n    error: [],\n    message: [],\n  }\n\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.longpollerTimeout The maximum timeout of a long poll AJAX request. Defaults to 20s (double the server long poll timer).\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   */\n  constructor(endPoint: string, options?: Options) {\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`\n\n    if (options?.params) this.params = options.params\n    if (options?.headers) this.headers = { ...this.headers, ...options.headers }\n    if (options?.timeout) this.timeout = options.timeout\n    if (options?.logger) this.logger = options.logger\n    if (options?.transport) this.transport = options.transport\n    if (options?.heartbeatIntervalMs)\n      this.heartbeatIntervalMs = options.heartbeatIntervalMs\n    if (options?.longpollerTimeout)\n      this.longpollerTimeout = options.longpollerTimeout\n\n    this.reconnectAfterMs = options?.reconnectAfterMs\n      ? options.reconnectAfterMs\n      : (tries: number) => {\n          return [1000, 2000, 5000, 10000][tries - 1] || 10000\n        }\n    this.encode = options?.encode\n      ? options.encode\n      : (payload: JSON, callback: Function) => {\n          return callback(JSON.stringify(payload))\n        }\n    this.decode = options?.decode\n      ? options.decode\n      : this.serializer.decode.bind(this.serializer)\n    this.reconnectTimer = new Timer(async () => {\n      await this.disconnect()\n      this.connect()\n    }, this.reconnectAfterMs)\n  }\n\n  /**\n   * Connects the socket, unless already connected.\n   */\n  connect(): void {\n    if (this.conn) {\n      return\n    }\n\n    this.conn = new this.transport(this.endPointURL(), [], null, this.headers)\n\n    if (this.conn) {\n      // this.conn.timeout = this.longpollerTimeout // TYPE ERROR\n      this.conn.binaryType = 'arraybuffer'\n      this.conn.onopen = () => this._onConnOpen()\n      this.conn.onerror = (error) => this._onConnError(error as ErrorEvent)\n      this.conn.onmessage = (event) => this.onConnMessage(event)\n      this.conn.onclose = (event) => this._onConnClose(event)\n    }\n  }\n\n  /**\n   * Disconnects the socket.\n   *\n   * @param code A numeric status code to send on disconnect.\n   * @param reason A custom reason for the disconnect.\n   */\n  disconnect(\n    code?: number,\n    reason?: string\n  ): Promise<{ error: Error | null; data: boolean }> {\n    return new Promise((resolve, _reject) => {\n      try {\n        if (this.conn) {\n          this.conn.onclose = function () {} // noop\n          if (code) {\n            this.conn.close(code, reason || '')\n          } else {\n            this.conn.close()\n          }\n          this.conn = null\n          // remove open handles\n          this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n          this.reconnectTimer.reset()\n        }\n        resolve({ error: null, data: true })\n      } catch (error) {\n        resolve({ error: error as Error, data: false })\n      }\n    })\n  }\n\n  /**\n   * Logs the message.\n   *\n   * For customized logging, `this.logger` can be overriden.\n   */\n  log(kind: string, msg: string, data?: any) {\n    this.logger(kind, msg, data)\n  }\n\n  /**\n   * Registers a callback for connection state change event.\n   *\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onOpen(() => console.log(\"Socket opened.\"))\n   */\n  onOpen(callback: Function) {\n    this.stateChangeCallbacks.open.push(callback)\n  }\n\n  /**\n   * Registers a callback for connection state change events.\n   *\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onOpen(() => console.log(\"Socket closed.\"))\n   */\n  onClose(callback: Function) {\n    this.stateChangeCallbacks.close.push(callback)\n  }\n\n  /**\n   * Registers a callback for connection state change events.\n   *\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onOpen((error) => console.log(\"An error occurred\"))\n   */\n  onError(callback: Function) {\n    this.stateChangeCallbacks.error.push(callback)\n  }\n\n  /**\n   * Calls a function any time a message is received.\n   *\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onMessage((message) => console.log(message))\n   */\n  onMessage(callback: Function) {\n    this.stateChangeCallbacks.message.push(callback)\n  }\n\n  /**\n   * Returns the current state of the socket.\n   */\n  connectionState(): CONNECTION_STATE {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing\n      default:\n        return CONNECTION_STATE.Closed\n    }\n  }\n\n  /**\n   * Retuns `true` is the connection is open.\n   */\n  isConnected(): boolean {\n    return this.connectionState() === CONNECTION_STATE.Open\n  }\n\n  /**\n   * Removes a subscription from the socket.\n   *\n   * @param channel An open subscription.\n   */\n  remove(channel: RealtimeSubscription) {\n    this.channels = this.channels.filter(\n      (c: RealtimeSubscription) => c.joinRef() !== channel.joinRef()\n    )\n  }\n\n  channel(topic: string, chanParams: ChannelParams = {}): RealtimeSubscription {\n    const chan = new RealtimeSubscription(topic, chanParams, this)\n    this.channels.push(chan)\n    return chan\n  }\n\n  /**\n   * Push out a message if the socket is connected.\n   *\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n   */\n  push(data: Message): void {\n    const { topic, event, payload, ref } = data\n    let callback = () => {\n      this.encode(data, (result: any) => {\n        this.conn?.send(result)\n      })\n    }\n    this.log('push', `${topic} ${event} (${ref})`, payload)\n    if (this.isConnected()) {\n      callback()\n    } else {\n      this.sendBuffer.push(callback)\n    }\n  }\n\n  onConnMessage(rawMessage: { data: any }) {\n    this.decode(rawMessage.data, (msg: Message) => {\n      let { topic, event, payload, ref } = msg\n\n      if (\n        (ref && ref === this.pendingHeartbeatRef) ||\n        event === payload?.type\n      ) {\n        this.pendingHeartbeatRef = null\n      }\n\n      this.log(\n        'receive',\n        `${payload.status || ''} ${topic} ${event} ${\n          (ref && '(' + ref + ')') || ''\n        }`,\n        payload\n      )\n      this.channels\n        .filter((channel: RealtimeSubscription) => channel.isMember(topic))\n        .forEach((channel: RealtimeSubscription) =>\n          channel.trigger(event, payload, ref)\n        )\n      this.stateChangeCallbacks.message.forEach((callback) => callback(msg))\n    })\n  }\n\n  /**\n   * Returns the URL of the websocket.\n   */\n  endPointURL(): string {\n    return this._appendParams(\n      this.endPoint,\n      Object.assign({}, this.params, { vsn: VSN })\n    )\n  }\n\n  /**\n   * Return the next message ref, accounting for overflows\n   */\n  makeRef(): string {\n    let newRef = this.ref + 1\n    if (newRef === this.ref) {\n      this.ref = 0\n    } else {\n      this.ref = newRef\n    }\n\n    return this.ref.toString()\n  }\n\n  /**\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n   *\n   * @param token A JWT string.\n   */\n  setAuth(token: string | null) {\n    this.accessToken = token\n\n    this.channels.forEach((channel) => {\n      token && channel.updateJoinPayload({ user_token: token })\n\n      if (channel.joinedOnce && channel.isJoined()) {\n        channel.push(CHANNEL_EVENTS.access_token, { access_token: token })\n      }\n    })\n  }\n\n  /**\n   * Unsubscribe from channels with the specified topic.\n   */\n  leaveOpenTopic(topic: string): void {\n    let dupChannel = this.channels.find(\n      (c) => c.topic === topic && (c.isJoined() || c.isJoining())\n    )\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`)\n      dupChannel.unsubscribe()\n    }\n  }\n\n  private _onConnOpen() {\n    this.log('transport', `connected to ${this.endPointURL()}`)\n    this._flushSendBuffer()\n    this.reconnectTimer.reset()\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.heartbeatTimer = setInterval(\n      () => this._sendHeartbeat(),\n      this.heartbeatIntervalMs\n    )\n    this.stateChangeCallbacks.open.forEach((callback) => callback())!\n  }\n\n  private _onConnClose(event: any) {\n    this.log('transport', 'close', event)\n    this._triggerChanError()\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.reconnectTimer.scheduleTimeout()\n    this.stateChangeCallbacks.close.forEach((callback) => callback(event))\n  }\n\n  private _onConnError(error: ErrorEvent) {\n    this.log('transport', error.message)\n    this._triggerChanError()\n    this.stateChangeCallbacks.error.forEach((callback) => callback(error))\n  }\n\n  private _triggerChanError() {\n    this.channels.forEach((channel: RealtimeSubscription) =>\n      channel.trigger(CHANNEL_EVENTS.error)\n    )\n  }\n\n  private _appendParams(\n    url: string,\n    params: { [key: string]: string }\n  ): string {\n    if (Object.keys(params).length === 0) {\n      return url\n    }\n    const prefix = url.match(/\\?/) ? '&' : '?'\n    const query = new URLSearchParams(params)\n\n    return `${url}${prefix}${query}`\n  }\n\n  private _flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach((callback) => callback())\n      this.sendBuffer = []\n    }\n  }\n\n  private _sendHeartbeat() {\n    if (!this.isConnected()) {\n      return\n    }\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null\n      this.log(\n        'transport',\n        'heartbeat timeout. Attempting to re-establish connection'\n      )\n      this.conn?.close(WS_CLOSE_NORMAL, 'hearbeat timeout')\n      return\n    }\n    this.pendingHeartbeatRef = this.makeRef()\n    this.push({\n      topic: 'phoenix',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef,\n    })\n    this.setAuth(this.accessToken)\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,YAAY,QAAQ,WAAW;AACxC,SACEC,GAAG,EACHC,cAAc,EACdC,UAAU,EACVC,aAAa,EACbC,eAAe,EACfC,eAAe,EACfC,eAAe,EACfC,gBAAgB,QACX,iBAAiB;AACxB,OAAOC,KAAK,MAAM,aAAa;AAC/B,OAAOC,UAAU,MAAM,kBAAkB;AACzC,OAAOC,oBAAoB,MAAM,wBAAwB;AA2BzD,IAAMC,IAAI,GAAG,SAAPA,IAAIA,CAAA,EAAQ,CAAE,CAAC;AAAA,IAEAC,cAAc;EAiCjC;;;;;;;;;;;;;;;EAeA,SAAAA,eAAYC,QAAgB,EAAEC,OAAiB;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAJ,cAAA;IA/C/C,KAAAK,WAAW,GAAkB,IAAI;IACjC,KAAAC,QAAQ,GAA2B,EAAE;IACrC,KAAAL,QAAQ,GAAW,EAAE;IACrB,KAAAM,OAAO,GAA+Bb,eAAe;IACrD,KAAAc,MAAM,GAA+B,EAAE;IACvC,KAAAC,OAAO,GAAWjB,eAAe;IACjC,KAAAkB,SAAS,GAAQvB,YAAY;IAC7B,KAAAwB,mBAAmB,GAAW,KAAK;IACnC,KAAAC,iBAAiB,GAAW,KAAK;IACjC,KAAAC,cAAc,GAA+CC,SAAS;IACtE,KAAAC,mBAAmB,GAAkB,IAAI;IACzC,KAAAC,GAAG,GAAW,CAAC;IAEf,KAAAC,MAAM,GAAalB,IAAI;IAIvB,KAAAmB,IAAI,GAAqB,IAAI;IAC7B,KAAAC,UAAU,GAAe,EAAE;IAC3B,KAAAC,UAAU,GAAe,IAAIvB,UAAU,EAAE;IACzC,KAAAwB,oBAAoB,GAKhB;MACFC,IAAI,EAAE,EAAE;MACRC,KAAK,EAAE,EAAE;MACTC,KAAK,EAAE,EAAE;MACTC,OAAO,EAAE;KACV;IAkBC,IAAI,CAACxB,QAAQ,MAAAyB,MAAA,CAAMzB,QAAQ,OAAAyB,MAAA,CAAIpC,UAAU,CAACqC,SAAS,CAAE;IAErD,IAAIzB,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEM,MAAM,EAAE,IAAI,CAACA,MAAM,GAAGN,OAAO,CAACM,MAAM;IACjD,IAAIN,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEK,OAAO,EAAE,IAAI,CAACA,OAAO,GAAAqB,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAQ,IAAI,CAACtB,OAAO,GAAKL,OAAO,CAACK,OAAO,CAAE;IAC5E,IAAIL,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEO,OAAO,EAAE,IAAI,CAACA,OAAO,GAAGP,OAAO,CAACO,OAAO;IACpD,IAAIP,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEe,MAAM,EAAE,IAAI,CAACA,MAAM,GAAGf,OAAO,CAACe,MAAM;IACjD,IAAIf,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEQ,SAAS,EAAE,IAAI,CAACA,SAAS,GAAGR,OAAO,CAACQ,SAAS;IAC1D,IAAIR,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAES,mBAAmB,EAC9B,IAAI,CAACA,mBAAmB,GAAGT,OAAO,CAACS,mBAAmB;IACxD,IAAIT,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEU,iBAAiB,EAC5B,IAAI,CAACA,iBAAiB,GAAGV,OAAO,CAACU,iBAAiB;IAEpD,IAAI,CAACkB,gBAAgB,GAAG,CAAA5B,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAE4B,gBAAgB,IAC7C5B,OAAO,CAAC4B,gBAAgB,GACxB,UAACC,KAAa,EAAI;MAChB,OAAO,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC,CAACA,KAAK,GAAG,CAAC,CAAC,IAAI,KAAK;IACtD,CAAC;IACL,IAAI,CAACC,MAAM,GAAG,CAAA9B,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAE8B,MAAM,IACzB9B,OAAO,CAAC8B,MAAM,GACd,UAACC,OAAa,EAAEC,QAAkB,EAAI;MACpC,OAAOA,QAAQ,CAACC,IAAI,CAACC,SAAS,CAACH,OAAO,CAAC,CAAC;IAC1C,CAAC;IACL,IAAI,CAACI,MAAM,GAAG,CAAAnC,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEmC,MAAM,IACzBnC,OAAO,CAACmC,MAAM,GACd,IAAI,CAACjB,UAAU,CAACiB,MAAM,CAACC,IAAI,CAAC,IAAI,CAAClB,UAAU,CAAC;IAChD,IAAI,CAACmB,cAAc,GAAG,IAAI3C,KAAK,CAAC;MAAA,OAAW4C,SAAA,CAAArC,KAAA,+BAAAsC,mBAAA,GAAAC,IAAA,UAAAC,QAAA;QAAA,OAAAF,mBAAA,GAAAG,IAAA,UAAAC,SAAAC,QAAA;UAAA;YAAA,QAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;cAAA;gBAAAF,QAAA,CAAAE,IAAA;gBACzC,OAAM,IAAI,CAACC,UAAU,EAAE;cAAA;gBACvB,IAAI,CAACC,OAAO,EAAE;cAAA;cAAA;gBAAA,OAAAJ,QAAA,CAAAK,IAAA;YAAA;UAAA;QAAA,GAAAR,OAAA;MAAA,CACf;IAAA,GAAE,IAAI,CAACb,gBAAgB,CAAC;EAC3B;EAEA;;;EAAAsB,YAAA,CAAApD,cAAA;IAAAqD,GAAA;IAAAC,KAAA,EAGA,SAAAJ,QAAA,EAAO;MAAA,IAAAK,MAAA;MACL,IAAI,IAAI,CAACrC,IAAI,EAAE;QACb;;MAGF,IAAI,CAACA,IAAI,GAAG,IAAI,IAAI,CAACR,SAAS,CAAC,IAAI,CAAC8C,WAAW,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,CAACjD,OAAO,CAAC;MAE1E,IAAI,IAAI,CAACW,IAAI,EAAE;QACb;QACA,IAAI,CAACA,IAAI,CAACuC,UAAU,GAAG,aAAa;QACpC,IAAI,CAACvC,IAAI,CAACwC,MAAM,GAAG;UAAA,OAAMH,MAAI,CAACI,WAAW,EAAE;QAAA;QAC3C,IAAI,CAACzC,IAAI,CAAC0C,OAAO,GAAG,UAACpC,KAAK;UAAA,OAAK+B,MAAI,CAACM,YAAY,CAACrC,KAAmB,CAAC;QAAA;QACrE,IAAI,CAACN,IAAI,CAAC4C,SAAS,GAAG,UAACC,KAAK;UAAA,OAAKR,MAAI,CAACS,aAAa,CAACD,KAAK,CAAC;QAAA;QAC1D,IAAI,CAAC7C,IAAI,CAAC+C,OAAO,GAAG,UAACF,KAAK;UAAA,OAAKR,MAAI,CAACW,YAAY,CAACH,KAAK,CAAC;QAAA;;IAE3D;IAEA;;;;;;EAAA;IAAAV,GAAA;IAAAC,KAAA,EAMA,SAAAL,WACEkB,IAAa,EACbC,MAAe;MAAA,IAAAC,MAAA;MAEf,OAAO,IAAIC,OAAO,CAAC,UAACC,OAAO,EAAEC,OAAO,EAAI;QACtC,IAAI;UACF,IAAIH,MAAI,CAACnD,IAAI,EAAE;YACbmD,MAAI,CAACnD,IAAI,CAAC+C,OAAO,GAAG,aAAa,CAAC,EAAC;YACnC,IAAIE,IAAI,EAAE;cACRE,MAAI,CAACnD,IAAI,CAACK,KAAK,CAAC4C,IAAI,EAAEC,MAAM,IAAI,EAAE,CAAC;aACpC,MAAM;cACLC,MAAI,CAACnD,IAAI,CAACK,KAAK,EAAE;;YAEnB8C,MAAI,CAACnD,IAAI,GAAG,IAAI;YAChB;YACAmD,MAAI,CAACxD,cAAc,IAAI4D,aAAa,CAACJ,MAAI,CAACxD,cAAc,CAAC;YACzDwD,MAAI,CAAC9B,cAAc,CAACmC,KAAK,EAAE;;UAE7BH,OAAO,CAAC;YAAE/C,KAAK,EAAE,IAAI;YAAEmD,IAAI,EAAE;UAAI,CAAE,CAAC;SACrC,CAAC,OAAOnD,KAAK,EAAE;UACd+C,OAAO,CAAC;YAAE/C,KAAK,EAAEA,KAAc;YAAEmD,IAAI,EAAE;UAAK,CAAE,CAAC;;MAEnD,CAAC,CAAC;IACJ;IAEA;;;;;EAAA;IAAAtB,GAAA;IAAAC,KAAA,EAKA,SAAAsB,IAAIC,IAAY,EAAEC,GAAW,EAAEH,IAAU;MACvC,IAAI,CAAC1D,MAAM,CAAC4D,IAAI,EAAEC,GAAG,EAAEH,IAAI,CAAC;IAC9B;IAEA;;;;;;;;EAAA;IAAAtB,GAAA;IAAAC,KAAA,EAQA,SAAAyB,OAAO7C,QAAkB;MACvB,IAAI,CAACb,oBAAoB,CAACC,IAAI,CAAC0D,IAAI,CAAC9C,QAAQ,CAAC;IAC/C;IAEA;;;;;;;;EAAA;IAAAmB,GAAA;IAAAC,KAAA,EAQA,SAAA2B,QAAQ/C,QAAkB;MACxB,IAAI,CAACb,oBAAoB,CAACE,KAAK,CAACyD,IAAI,CAAC9C,QAAQ,CAAC;IAChD;IAEA;;;;;;;;EAAA;IAAAmB,GAAA;IAAAC,KAAA,EAQA,SAAA4B,QAAQhD,QAAkB;MACxB,IAAI,CAACb,oBAAoB,CAACG,KAAK,CAACwD,IAAI,CAAC9C,QAAQ,CAAC;IAChD;IAEA;;;;;;;;EAAA;IAAAmB,GAAA;IAAAC,KAAA,EAQA,SAAA6B,UAAUjD,QAAkB;MAC1B,IAAI,CAACb,oBAAoB,CAACI,OAAO,CAACuD,IAAI,CAAC9C,QAAQ,CAAC;IAClD;IAEA;;;EAAA;IAAAmB,GAAA;IAAAC,KAAA,EAGA,SAAA8B,gBAAA,EAAe;MACb,QAAQ,IAAI,CAAClE,IAAI,IAAI,IAAI,CAACA,IAAI,CAACmE,UAAU;QACvC,KAAK9F,aAAa,CAAC+F,UAAU;UAC3B,OAAO3F,gBAAgB,CAAC4F,UAAU;QACpC,KAAKhG,aAAa,CAAC+B,IAAI;UACrB,OAAO3B,gBAAgB,CAAC6F,IAAI;QAC9B,KAAKjG,aAAa,CAACkG,OAAO;UACxB,OAAO9F,gBAAgB,CAAC+F,OAAO;QACjC;UACE,OAAO/F,gBAAgB,CAACgG,MAAM;;IAEpC;IAEA;;;EAAA;IAAAtC,GAAA;IAAAC,KAAA,EAGA,SAAAsC,YAAA,EAAW;MACT,OAAO,IAAI,CAACR,eAAe,EAAE,KAAKzF,gBAAgB,CAAC6F,IAAI;IACzD;IAEA;;;;;EAAA;IAAAnC,GAAA;IAAAC,KAAA,EAKA,SAAAuC,OAAOC,OAA6B;MAClC,IAAI,CAACxF,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAACyF,MAAM,CAClC,UAACC,CAAuB;QAAA,OAAKA,CAAC,CAACC,OAAO,EAAE,KAAKH,OAAO,CAACG,OAAO,EAAE;MAAA,EAC/D;IACH;EAAC;IAAA5C,GAAA;IAAAC,KAAA,EAED,SAAAwC,QAAQI,KAAa,EAAgC;MAAA,IAA9BC,UAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAtF,SAAA,GAAAsF,SAAA,MAA4B,EAAE;MACnD,IAAME,IAAI,GAAG,IAAIxG,oBAAoB,CAACoG,KAAK,EAAEC,UAAU,EAAE,IAAI,CAAC;MAC9D,IAAI,CAAC7F,QAAQ,CAAC0E,IAAI,CAACsB,IAAI,CAAC;MACxB,OAAOA,IAAI;IACb;IAEA;;;;;EAAA;IAAAjD,GAAA;IAAAC,KAAA,EAKA,SAAA0B,KAAKL,IAAa;MAAA,IAAA4B,MAAA;MAChB,IAAQL,KAAK,GAA0BvB,IAAI,CAAnCuB,KAAK;QAAEnC,KAAK,GAAmBY,IAAI,CAA5BZ,KAAK;QAAE9B,OAAO,GAAU0C,IAAI,CAArB1C,OAAO;QAAEjB,GAAG,GAAK2D,IAAI,CAAZ3D,GAAG;MAClC,IAAIkB,QAAQ,GAAG,SAAXA,QAAQA,CAAA,EAAQ;QAClBqE,MAAI,CAACvE,MAAM,CAAC2C,IAAI,EAAE,UAAC6B,MAAW,EAAI;;UAChC,CAAAC,EAAA,GAAAF,MAAI,CAACrF,IAAI,cAAAuF,EAAA,uBAAAA,EAAA,CAAEC,IAAI,CAACF,MAAM;QACxB,CAAC,CAAC;MACJ,CAAC;MACD,IAAI,CAAC5B,GAAG,CAAC,MAAM,KAAAlD,MAAA,CAAKwE,KAAK,OAAAxE,MAAA,CAAIqC,KAAK,QAAArC,MAAA,CAAKV,GAAG,QAAKiB,OAAO,CAAC;MACvD,IAAI,IAAI,CAAC2D,WAAW,EAAE,EAAE;QACtB1D,QAAQ,EAAE;OACX,MAAM;QACL,IAAI,CAACf,UAAU,CAAC6D,IAAI,CAAC9C,QAAQ,CAAC;;IAElC;EAAC;IAAAmB,GAAA;IAAAC,KAAA,EAED,SAAAU,cAAc2C,UAAyB;MAAA,IAAAC,MAAA;MACrC,IAAI,CAACvE,MAAM,CAACsE,UAAU,CAAChC,IAAI,EAAE,UAACG,GAAY,EAAI;QAC5C,IAAMoB,KAAK,GAA0BpB,GAAG,CAAlCoB,KAAK;UAAEnC,KAAK,GAAmBe,GAAG,CAA3Bf,KAAK;UAAE9B,OAAO,GAAU6C,GAAG,CAApB7C,OAAO;UAAEjB,GAAG,GAAK8D,GAAG,CAAX9D,GAAG;QAEhC,IACGA,GAAG,IAAIA,GAAG,KAAK4F,MAAI,CAAC7F,mBAAmB,IACxCgD,KAAK,MAAK9B,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAE4E,IAAI,GACvB;UACAD,MAAI,CAAC7F,mBAAmB,GAAG,IAAI;;QAGjC6F,MAAI,CAAChC,GAAG,CACN,SAAS,KAAAlD,MAAA,CACNO,OAAO,CAAC6E,MAAM,IAAI,EAAE,OAAApF,MAAA,CAAIwE,KAAK,OAAAxE,MAAA,CAAIqC,KAAK,OAAArC,MAAA,CACtCV,GAAG,IAAI,GAAG,GAAGA,GAAG,GAAG,GAAG,IAAK,EAC9B,GACAiB,OAAO,CACR;QACD2E,MAAI,CAACtG,QAAQ,CACVyF,MAAM,CAAC,UAACD,OAA6B;UAAA,OAAKA,OAAO,CAACiB,QAAQ,CAACb,KAAK,CAAC;QAAA,EAAC,CAClEc,OAAO,CAAC,UAAClB,OAA6B;UAAA,OACrCA,OAAO,CAACmB,OAAO,CAAClD,KAAK,EAAE9B,OAAO,EAAEjB,GAAG,CAAC;QAAA,EACrC;QACH4F,MAAI,CAACvF,oBAAoB,CAACI,OAAO,CAACuF,OAAO,CAAC,UAAC9E,QAAQ;UAAA,OAAKA,QAAQ,CAAC4C,GAAG,CAAC;QAAA,EAAC;MACxE,CAAC,CAAC;IACJ;IAEA;;;EAAA;IAAAzB,GAAA;IAAAC,KAAA,EAGA,SAAAE,YAAA,EAAW;MACT,OAAO,IAAI,CAAC0D,aAAa,CACvB,IAAI,CAACjH,QAAQ,EACb2B,MAAM,CAACC,MAAM,CAAC,EAAE,EAAE,IAAI,CAACrB,MAAM,EAAE;QAAE2G,GAAG,EAAE/H;MAAG,CAAE,CAAC,CAC7C;IACH;IAEA;;;EAAA;IAAAiE,GAAA;IAAAC,KAAA,EAGA,SAAA8D,QAAA,EAAO;MACL,IAAIC,MAAM,GAAG,IAAI,CAACrG,GAAG,GAAG,CAAC;MACzB,IAAIqG,MAAM,KAAK,IAAI,CAACrG,GAAG,EAAE;QACvB,IAAI,CAACA,GAAG,GAAG,CAAC;OACb,MAAM;QACL,IAAI,CAACA,GAAG,GAAGqG,MAAM;;MAGnB,OAAO,IAAI,CAACrG,GAAG,CAACsG,QAAQ,EAAE;IAC5B;IAEA;;;;;EAAA;IAAAjE,GAAA;IAAAC,KAAA,EAKA,SAAAiE,QAAQC,KAAoB;MAC1B,IAAI,CAACnH,WAAW,GAAGmH,KAAK;MAExB,IAAI,CAAClH,QAAQ,CAAC0G,OAAO,CAAC,UAAClB,OAAO,EAAI;QAChC0B,KAAK,IAAI1B,OAAO,CAAC2B,iBAAiB,CAAC;UAAEC,UAAU,EAAEF;QAAK,CAAE,CAAC;QAEzD,IAAI1B,OAAO,CAAC6B,UAAU,IAAI7B,OAAO,CAAC8B,QAAQ,EAAE,EAAE;UAC5C9B,OAAO,CAACd,IAAI,CAAC3F,cAAc,CAACwI,YAAY,EAAE;YAAEA,YAAY,EAAEL;UAAK,CAAE,CAAC;;MAEtE,CAAC,CAAC;IACJ;IAEA;;;EAAA;IAAAnE,GAAA;IAAAC,KAAA,EAGA,SAAAwE,eAAe5B,KAAa;MAC1B,IAAI6B,UAAU,GAAG,IAAI,CAACzH,QAAQ,CAAC0H,IAAI,CACjC,UAAChC,CAAC;QAAA,OAAKA,CAAC,CAACE,KAAK,KAAKA,KAAK,KAAKF,CAAC,CAAC4B,QAAQ,EAAE,IAAI5B,CAAC,CAACiC,SAAS,EAAE,CAAC;MAAA,EAC5D;MACD,IAAIF,UAAU,EAAE;QACd,IAAI,CAACnD,GAAG,CAAC,WAAW,+BAAAlD,MAAA,CAA8BwE,KAAK,OAAG,CAAC;QAC3D6B,UAAU,CAACG,WAAW,EAAE;;IAE5B;EAAC;IAAA7E,GAAA;IAAAC,KAAA,EAEO,SAAAK,YAAA,EAAW;MAAA,IAAAwE,MAAA;MACjB,IAAI,CAACvD,GAAG,CAAC,WAAW,kBAAAlD,MAAA,CAAkB,IAAI,CAAC8B,WAAW,EAAE,CAAE,CAAC;MAC3D,IAAI,CAAC4E,gBAAgB,EAAE;MACvB,IAAI,CAAC7F,cAAc,CAACmC,KAAK,EAAE;MAC3B,IAAI,CAAC7D,cAAc,IAAI4D,aAAa,CAAC,IAAI,CAAC5D,cAAc,CAAC;MACzD,IAAI,CAACA,cAAc,GAAGwH,WAAW,CAC/B;QAAA,OAAMF,MAAI,CAACG,cAAc,EAAE;MAAA,GAC3B,IAAI,CAAC3H,mBAAmB,CACzB;MACD,IAAI,CAACU,oBAAoB,CAACC,IAAI,CAAC0F,OAAO,CAAC,UAAC9E,QAAQ;QAAA,OAAKA,QAAQ,EAAE;MAAA,EAAE;IACnE;EAAC;IAAAmB,GAAA;IAAAC,KAAA,EAEO,SAAAY,aAAaH,KAAU;MAC7B,IAAI,CAACa,GAAG,CAAC,WAAW,EAAE,OAAO,EAAEb,KAAK,CAAC;MACrC,IAAI,CAACwE,iBAAiB,EAAE;MACxB,IAAI,CAAC1H,cAAc,IAAI4D,aAAa,CAAC,IAAI,CAAC5D,cAAc,CAAC;MACzD,IAAI,CAAC0B,cAAc,CAACiG,eAAe,EAAE;MACrC,IAAI,CAACnH,oBAAoB,CAACE,KAAK,CAACyF,OAAO,CAAC,UAAC9E,QAAQ;QAAA,OAAKA,QAAQ,CAAC6B,KAAK,CAAC;MAAA,EAAC;IACxE;EAAC;IAAAV,GAAA;IAAAC,KAAA,EAEO,SAAAO,aAAarC,KAAiB;MACpC,IAAI,CAACoD,GAAG,CAAC,WAAW,EAAEpD,KAAK,CAACC,OAAO,CAAC;MACpC,IAAI,CAAC8G,iBAAiB,EAAE;MACxB,IAAI,CAAClH,oBAAoB,CAACG,KAAK,CAACwF,OAAO,CAAC,UAAC9E,QAAQ;QAAA,OAAKA,QAAQ,CAACV,KAAK,CAAC;MAAA,EAAC;IACxE;EAAC;IAAA6B,GAAA;IAAAC,KAAA,EAEO,SAAAiF,kBAAA,EAAiB;MACvB,IAAI,CAACjI,QAAQ,CAAC0G,OAAO,CAAC,UAAClB,OAA6B;QAAA,OAClDA,OAAO,CAACmB,OAAO,CAAC5H,cAAc,CAACmC,KAAK,CAAC;MAAA,EACtC;IACH;EAAC;IAAA6B,GAAA;IAAAC,KAAA,EAEO,SAAA4D,cACNuB,GAAW,EACXjI,MAAiC;MAEjC,IAAIoB,MAAM,CAAC8G,IAAI,CAAClI,MAAM,CAAC,CAAC6F,MAAM,KAAK,CAAC,EAAE;QACpC,OAAOoC,GAAG;;MAEZ,IAAME,MAAM,GAAGF,GAAG,CAACG,KAAK,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG;MAC1C,IAAMC,KAAK,GAAG,IAAIC,eAAe,CAACtI,MAAM,CAAC;MAEzC,UAAAkB,MAAA,CAAU+G,GAAG,EAAA/G,MAAA,CAAGiH,MAAM,EAAAjH,MAAA,CAAGmH,KAAK;IAChC;EAAC;IAAAxF,GAAA;IAAAC,KAAA,EAEO,SAAA8E,iBAAA,EAAgB;MACtB,IAAI,IAAI,CAACxC,WAAW,EAAE,IAAI,IAAI,CAACzE,UAAU,CAACkF,MAAM,GAAG,CAAC,EAAE;QACpD,IAAI,CAAClF,UAAU,CAAC6F,OAAO,CAAC,UAAC9E,QAAQ;UAAA,OAAKA,QAAQ,EAAE;QAAA,EAAC;QACjD,IAAI,CAACf,UAAU,GAAG,EAAE;;IAExB;EAAC;IAAAkC,GAAA;IAAAC,KAAA,EAEO,SAAAgF,eAAA,EAAc;;MACpB,IAAI,CAAC,IAAI,CAAC1C,WAAW,EAAE,EAAE;QACvB;;MAEF,IAAI,IAAI,CAAC7E,mBAAmB,EAAE;QAC5B,IAAI,CAACA,mBAAmB,GAAG,IAAI;QAC/B,IAAI,CAAC6D,GAAG,CACN,WAAW,EACX,0DAA0D,CAC3D;QACD,CAAA6B,EAAA,OAAI,CAACvF,IAAI,cAAAuF,EAAA,uBAAAA,EAAA,CAAElF,KAAK,CAAC9B,eAAe,EAAE,kBAAkB;QACpD;;MAEF,IAAI,CAACsB,mBAAmB,GAAG,IAAI,CAACqG,OAAO,EAAE;MACzC,IAAI,CAACpC,IAAI,CAAC;QACRkB,KAAK,EAAE,SAAS;QAChBnC,KAAK,EAAE,WAAW;QAClB9B,OAAO,EAAE,EAAE;QACXjB,GAAG,EAAE,IAAI,CAACD;OACX,CAAC;MACF,IAAI,CAACwG,OAAO,CAAC,IAAI,CAAClH,WAAW,CAAC;IAChC;EAAC;EAAA,OAAAL,cAAA;AAAA;AAAA,SAlZkBA,cAAc,IAAA+I,OAAA"},"metadata":{},"sourceType":"module"}