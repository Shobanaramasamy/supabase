{"ast":null,"code":"import _classCallCheck from \"/Users/mako/Downloads/todo_supabase/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/mako/Downloads/todo_supabase/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/mako/Downloads/todo_supabase/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/mako/Downloads/todo_supabase/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport PostgrestTransformBuilder from './PostgrestTransformBuilder';\nvar PostgrestFilterBuilder = /*#__PURE__*/function (_PostgrestTransformBu) {\n  _inherits(PostgrestFilterBuilder, _PostgrestTransformBu);\n  var _super = _createSuper(PostgrestFilterBuilder);\n  function PostgrestFilterBuilder() {\n    var _this;\n    _classCallCheck(this, PostgrestFilterBuilder);\n    _this = _super.apply(this, arguments);\n    /** @deprecated Use `contains()` instead. */\n    _this.cs = _this.contains;\n    /** @deprecated Use `containedBy()` instead. */\n    _this.cd = _this.containedBy;\n    /** @deprecated Use `rangeLt()` instead. */\n    _this.sl = _this.rangeLt;\n    /** @deprecated Use `rangeGt()` instead. */\n    _this.sr = _this.rangeGt;\n    /** @deprecated Use `rangeGte()` instead. */\n    _this.nxl = _this.rangeGte;\n    /** @deprecated Use `rangeLte()` instead. */\n    _this.nxr = _this.rangeLte;\n    /** @deprecated Use `rangeAdjacent()` instead. */\n    _this.adj = _this.rangeAdjacent;\n    /** @deprecated Use `overlaps()` instead. */\n    _this.ov = _this.overlaps;\n    return _this;\n  }\n  /**\n   * Finds all rows which doesn't satisfy the filter.\n   *\n   * @param column  The column to filter on.\n   * @param operator  The operator to filter with.\n   * @param value  The value to filter with.\n   */\n  _createClass(PostgrestFilterBuilder, [{\n    key: \"not\",\n    value: function not(column, operator, value) {\n      this.url.searchParams.append(\"\".concat(column), \"not.\".concat(operator, \".\").concat(value));\n      return this;\n    }\n    /**\n     * Finds all rows satisfying at least one of the filters.\n     *\n     * @param filters  The filters to use, separated by commas.\n     * @param foreignTable  The foreign table to use (if `column` is a foreign column).\n     */\n  }, {\n    key: \"or\",\n    value: function or(filters) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        foreignTable = _ref.foreignTable;\n      var key = typeof foreignTable === 'undefined' ? 'or' : \"\".concat(foreignTable, \".or\");\n      this.url.searchParams.append(key, \"(\".concat(filters, \")\"));\n      return this;\n    }\n    /**\n     * Finds all rows whose value on the stated `column` exactly matches the\n     * specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */\n  }, {\n    key: \"eq\",\n    value: function eq(column, value) {\n      this.url.searchParams.append(\"\".concat(column), \"eq.\".concat(value));\n      return this;\n    }\n    /**\n     * Finds all rows whose value on the stated `column` doesn't match the\n     * specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */\n  }, {\n    key: \"neq\",\n    value: function neq(column, value) {\n      this.url.searchParams.append(\"\".concat(column), \"neq.\".concat(value));\n      return this;\n    }\n    /**\n     * Finds all rows whose value on the stated `column` is greater than the\n     * specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */\n  }, {\n    key: \"gt\",\n    value: function gt(column, value) {\n      this.url.searchParams.append(\"\".concat(column), \"gt.\".concat(value));\n      return this;\n    }\n    /**\n     * Finds all rows whose value on the stated `column` is greater than or\n     * equal to the specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */\n  }, {\n    key: \"gte\",\n    value: function gte(column, value) {\n      this.url.searchParams.append(\"\".concat(column), \"gte.\".concat(value));\n      return this;\n    }\n    /**\n     * Finds all rows whose value on the stated `column` is less than the\n     * specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */\n  }, {\n    key: \"lt\",\n    value: function lt(column, value) {\n      this.url.searchParams.append(\"\".concat(column), \"lt.\".concat(value));\n      return this;\n    }\n    /**\n     * Finds all rows whose value on the stated `column` is less than or equal\n     * to the specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */\n  }, {\n    key: \"lte\",\n    value: function lte(column, value) {\n      this.url.searchParams.append(\"\".concat(column), \"lte.\".concat(value));\n      return this;\n    }\n    /**\n     * Finds all rows whose value in the stated `column` matches the supplied\n     * `pattern` (case sensitive).\n     *\n     * @param column  The column to filter on.\n     * @param pattern  The pattern to filter with.\n     */\n  }, {\n    key: \"like\",\n    value: function like(column, pattern) {\n      this.url.searchParams.append(\"\".concat(column), \"like.\".concat(pattern));\n      return this;\n    }\n    /**\n     * Finds all rows whose value in the stated `column` matches the supplied\n     * `pattern` (case insensitive).\n     *\n     * @param column  The column to filter on.\n     * @param pattern  The pattern to filter with.\n     */\n  }, {\n    key: \"ilike\",\n    value: function ilike(column, pattern) {\n      this.url.searchParams.append(\"\".concat(column), \"ilike.\".concat(pattern));\n      return this;\n    }\n    /**\n     * A check for exact equality (null, true, false), finds all rows whose\n     * value on the stated `column` exactly match the specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */\n  }, {\n    key: \"is\",\n    value: function is(column, value) {\n      this.url.searchParams.append(\"\".concat(column), \"is.\".concat(value));\n      return this;\n    }\n    /**\n     * Finds all rows whose value on the stated `column` is found on the\n     * specified `values`.\n     *\n     * @param column  The column to filter on.\n     * @param values  The values to filter with.\n     */\n  }, {\n    key: \"in\",\n    value: function _in(column, values) {\n      var cleanedValues = values.map(function (s) {\n        // handle postgrest reserved characters\n        // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n        if (typeof s === 'string' && new RegExp('[,()]').test(s)) return \"\\\"\".concat(s, \"\\\"\");else return \"\".concat(s);\n      }).join(',');\n      this.url.searchParams.append(\"\".concat(column), \"in.(\".concat(cleanedValues, \")\"));\n      return this;\n    }\n    /**\n     * Finds all rows whose json, array, or range value on the stated `column`\n     * contains the values specified in `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */\n  }, {\n    key: \"contains\",\n    value: function contains(column, value) {\n      if (typeof value === 'string') {\n        // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n        // keep it simple and accept a string\n        this.url.searchParams.append(\"\".concat(column), \"cs.\".concat(value));\n      } else if (Array.isArray(value)) {\n        // array\n        this.url.searchParams.append(\"\".concat(column), \"cs.{\".concat(value.join(','), \"}\"));\n      } else {\n        // json\n        this.url.searchParams.append(\"\".concat(column), \"cs.\".concat(JSON.stringify(value)));\n      }\n      return this;\n    }\n    /**\n     * Finds all rows whose json, array, or range value on the stated `column` is\n     * contained by the specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */\n  }, {\n    key: \"containedBy\",\n    value: function containedBy(column, value) {\n      if (typeof value === 'string') {\n        // range\n        this.url.searchParams.append(\"\".concat(column), \"cd.\".concat(value));\n      } else if (Array.isArray(value)) {\n        // array\n        this.url.searchParams.append(\"\".concat(column), \"cd.{\".concat(value.join(','), \"}\"));\n      } else {\n        // json\n        this.url.searchParams.append(\"\".concat(column), \"cd.\".concat(JSON.stringify(value)));\n      }\n      return this;\n    }\n    /**\n     * Finds all rows whose range value on the stated `column` is strictly to the\n     * left of the specified `range`.\n     *\n     * @param column  The column to filter on.\n     * @param range  The range to filter with.\n     */\n  }, {\n    key: \"rangeLt\",\n    value: function rangeLt(column, range) {\n      this.url.searchParams.append(\"\".concat(column), \"sl.\".concat(range));\n      return this;\n    }\n    /**\n     * Finds all rows whose range value on the stated `column` is strictly to\n     * the right of the specified `range`.\n     *\n     * @param column  The column to filter on.\n     * @param range  The range to filter with.\n     */\n  }, {\n    key: \"rangeGt\",\n    value: function rangeGt(column, range) {\n      this.url.searchParams.append(\"\".concat(column), \"sr.\".concat(range));\n      return this;\n    }\n    /**\n     * Finds all rows whose range value on the stated `column` does not extend\n     * to the left of the specified `range`.\n     *\n     * @param column  The column to filter on.\n     * @param range  The range to filter with.\n     */\n  }, {\n    key: \"rangeGte\",\n    value: function rangeGte(column, range) {\n      this.url.searchParams.append(\"\".concat(column), \"nxl.\".concat(range));\n      return this;\n    }\n    /**\n     * Finds all rows whose range value on the stated `column` does not extend\n     * to the right of the specified `range`.\n     *\n     * @param column  The column to filter on.\n     * @param range  The range to filter with.\n     */\n  }, {\n    key: \"rangeLte\",\n    value: function rangeLte(column, range) {\n      this.url.searchParams.append(\"\".concat(column), \"nxr.\".concat(range));\n      return this;\n    }\n    /**\n     * Finds all rows whose range value on the stated `column` is adjacent to\n     * the specified `range`.\n     *\n     * @param column  The column to filter on.\n     * @param range  The range to filter with.\n     */\n  }, {\n    key: \"rangeAdjacent\",\n    value: function rangeAdjacent(column, range) {\n      this.url.searchParams.append(\"\".concat(column), \"adj.\".concat(range));\n      return this;\n    }\n    /**\n     * Finds all rows whose array or range value on the stated `column` overlaps\n     * (has a value in common) with the specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */\n  }, {\n    key: \"overlaps\",\n    value: function overlaps(column, value) {\n      if (typeof value === 'string') {\n        // range\n        this.url.searchParams.append(\"\".concat(column), \"ov.\".concat(value));\n      } else {\n        // array\n        this.url.searchParams.append(\"\".concat(column), \"ov.{\".concat(value.join(','), \"}\"));\n      }\n      return this;\n    }\n    /**\n     * Finds all rows whose text or tsvector value on the stated `column` matches\n     * the tsquery in `query`.\n     *\n     * @param column  The column to filter on.\n     * @param query  The Postgres tsquery string to filter with.\n     * @param config  The text search configuration to use.\n     * @param type  The type of tsquery conversion to use on `query`.\n     */\n  }, {\n    key: \"textSearch\",\n    value: function textSearch(column, query) {\n      var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        config = _ref2.config,\n        _ref2$type = _ref2.type,\n        type = _ref2$type === void 0 ? null : _ref2$type;\n      var typePart = '';\n      if (type === 'plain') {\n        typePart = 'pl';\n      } else if (type === 'phrase') {\n        typePart = 'ph';\n      } else if (type === 'websearch') {\n        typePart = 'w';\n      }\n      var configPart = config === undefined ? '' : \"(\".concat(config, \")\");\n      this.url.searchParams.append(\"\".concat(column), \"\".concat(typePart, \"fts\").concat(configPart, \".\").concat(query));\n      return this;\n    }\n    /**\n     * Finds all rows whose tsvector value on the stated `column` matches\n     * to_tsquery(`query`).\n     *\n     * @param column  The column to filter on.\n     * @param query  The Postgres tsquery string to filter with.\n     * @param config  The text search configuration to use.\n     *\n     * @deprecated Use `textSearch()` instead.\n     */\n  }, {\n    key: \"fts\",\n    value: function fts(column, query) {\n      var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        config = _ref3.config;\n      var configPart = typeof config === 'undefined' ? '' : \"(\".concat(config, \")\");\n      this.url.searchParams.append(\"\".concat(column), \"fts\".concat(configPart, \".\").concat(query));\n      return this;\n    }\n    /**\n     * Finds all rows whose tsvector value on the stated `column` matches\n     * plainto_tsquery(`query`).\n     *\n     * @param column  The column to filter on.\n     * @param query  The Postgres tsquery string to filter with.\n     * @param config  The text search configuration to use.\n     *\n     * @deprecated Use `textSearch()` with `type: 'plain'` instead.\n     */\n  }, {\n    key: \"plfts\",\n    value: function plfts(column, query) {\n      var _ref4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        config = _ref4.config;\n      var configPart = typeof config === 'undefined' ? '' : \"(\".concat(config, \")\");\n      this.url.searchParams.append(\"\".concat(column), \"plfts\".concat(configPart, \".\").concat(query));\n      return this;\n    }\n    /**\n     * Finds all rows whose tsvector value on the stated `column` matches\n     * phraseto_tsquery(`query`).\n     *\n     * @param column  The column to filter on.\n     * @param query  The Postgres tsquery string to filter with.\n     * @param config  The text search configuration to use.\n     *\n     * @deprecated Use `textSearch()` with `type: 'phrase'` instead.\n     */\n  }, {\n    key: \"phfts\",\n    value: function phfts(column, query) {\n      var _ref5 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        config = _ref5.config;\n      var configPart = typeof config === 'undefined' ? '' : \"(\".concat(config, \")\");\n      this.url.searchParams.append(\"\".concat(column), \"phfts\".concat(configPart, \".\").concat(query));\n      return this;\n    }\n    /**\n     * Finds all rows whose tsvector value on the stated `column` matches\n     * websearch_to_tsquery(`query`).\n     *\n     * @param column  The column to filter on.\n     * @param query  The Postgres tsquery string to filter with.\n     * @param config  The text search configuration to use.\n     *\n     * @deprecated Use `textSearch()` with `type: 'websearch'` instead.\n     */\n  }, {\n    key: \"wfts\",\n    value: function wfts(column, query) {\n      var _ref6 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        config = _ref6.config;\n      var configPart = typeof config === 'undefined' ? '' : \"(\".concat(config, \")\");\n      this.url.searchParams.append(\"\".concat(column), \"wfts\".concat(configPart, \".\").concat(query));\n      return this;\n    }\n    /**\n     * Finds all rows whose `column` satisfies the filter.\n     *\n     * @param column  The column to filter on.\n     * @param operator  The operator to filter with.\n     * @param value  The value to filter with.\n     */\n  }, {\n    key: \"filter\",\n    value: function filter(column, operator, value) {\n      this.url.searchParams.append(\"\".concat(column), \"\".concat(operator, \".\").concat(value));\n      return this;\n    }\n    /**\n     * Finds all rows whose columns match the specified `query` object.\n     *\n     * @param query  The object to filter with, with column names as keys mapped\n     *               to their filter values.\n     */\n  }, {\n    key: \"match\",\n    value: function match(query) {\n      var _this2 = this;\n      Object.keys(query).forEach(function (key) {\n        _this2.url.searchParams.append(\"\".concat(key), \"eq.\".concat(query[key]));\n      });\n      return this;\n    }\n  }]);\n  return PostgrestFilterBuilder;\n}(PostgrestTransformBuilder);\nexport { PostgrestFilterBuilder as default };","map":{"version":3,"names":["PostgrestTransformBuilder","PostgrestFilterBuilder","_PostgrestTransformBu","_inherits","_super","_createSuper","_this","_classCallCheck","cs","contains","cd","containedBy","sl","rangeLt","sr","rangeGt","nxl","rangeGte","nxr","rangeLte","adj","rangeAdjacent","ov","overlaps","_createClass","key","value","not","column","operator","url","searchParams","append","concat","or","filters","_ref","arguments","length","undefined","foreignTable","eq","neq","gt","gte","lt","lte","like","pattern","ilike","is","_in","values","cleanedValues","map","s","RegExp","test","join","Array","isArray","JSON","stringify","range","textSearch","query","_ref2","config","_ref2$type","type","typePart","configPart","fts","_ref3","plfts","_ref4","phfts","_ref5","wfts","_ref6","filter","match","_this2","Object","keys","forEach","default"],"sources":["/Users/mako/Downloads/todo_supabase/node_modules/@supabase/postgrest-js/src/lib/PostgrestFilterBuilder.ts"],"sourcesContent":["import PostgrestTransformBuilder from './PostgrestTransformBuilder'\n\n/**\n * Filters\n */\n\ntype FilterOperator =\n  | 'eq'\n  | 'neq'\n  | 'gt'\n  | 'gte'\n  | 'lt'\n  | 'lte'\n  | 'like'\n  | 'ilike'\n  | 'is'\n  | 'in'\n  | 'cs'\n  | 'cd'\n  | 'sl'\n  | 'sr'\n  | 'nxl'\n  | 'nxr'\n  | 'adj'\n  | 'ov'\n  | 'fts'\n  | 'plfts'\n  | 'phfts'\n  | 'wfts'\n  | 'not.eq'\n  | 'not.neq'\n  | 'not.gt'\n  | 'not.gte'\n  | 'not.lt'\n  | 'not.lte'\n  | 'not.like'\n  | 'not.ilike'\n  | 'not.is'\n  | 'not.in'\n  | 'not.cs'\n  | 'not.cd'\n  | 'not.sl'\n  | 'not.sr'\n  | 'not.nxl'\n  | 'not.nxr'\n  | 'not.adj'\n  | 'not.ov'\n  | 'not.fts'\n  | 'not.plfts'\n  | 'not.phfts'\n  | 'not.wfts'\n\nexport default class PostgrestFilterBuilder<T> extends PostgrestTransformBuilder<T> {\n  /**\n   * Finds all rows which doesn't satisfy the filter.\n   *\n   * @param column  The column to filter on.\n   * @param operator  The operator to filter with.\n   * @param value  The value to filter with.\n   */\n  not(column: keyof T, operator: FilterOperator, value: any): this {\n    this.url.searchParams.append(`${column}`, `not.${operator}.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows satisfying at least one of the filters.\n   *\n   * @param filters  The filters to use, separated by commas.\n   * @param foreignTable  The foreign table to use (if `column` is a foreign column).\n   */\n  or(filters: string, { foreignTable }: { foreignTable?: string } = {}): this {\n    const key = typeof foreignTable === 'undefined' ? 'or' : `${foreignTable}.or`\n    this.url.searchParams.append(key, `(${filters})`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value on the stated `column` exactly matches the\n   * specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  eq(column: keyof T, value: T[keyof T]): this {\n    this.url.searchParams.append(`${column}`, `eq.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value on the stated `column` doesn't match the\n   * specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  neq(column: keyof T, value: T[keyof T]): this {\n    this.url.searchParams.append(`${column}`, `neq.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value on the stated `column` is greater than the\n   * specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  gt(column: keyof T, value: T[keyof T]): this {\n    this.url.searchParams.append(`${column}`, `gt.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value on the stated `column` is greater than or\n   * equal to the specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  gte(column: keyof T, value: T[keyof T]): this {\n    this.url.searchParams.append(`${column}`, `gte.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value on the stated `column` is less than the\n   * specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  lt(column: keyof T, value: T[keyof T]): this {\n    this.url.searchParams.append(`${column}`, `lt.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value on the stated `column` is less than or equal\n   * to the specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  lte(column: keyof T, value: T[keyof T]): this {\n    this.url.searchParams.append(`${column}`, `lte.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value in the stated `column` matches the supplied\n   * `pattern` (case sensitive).\n   *\n   * @param column  The column to filter on.\n   * @param pattern  The pattern to filter with.\n   */\n  like(column: keyof T, pattern: string): this {\n    this.url.searchParams.append(`${column}`, `like.${pattern}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value in the stated `column` matches the supplied\n   * `pattern` (case insensitive).\n   *\n   * @param column  The column to filter on.\n   * @param pattern  The pattern to filter with.\n   */\n  ilike(column: keyof T, pattern: string): this {\n    this.url.searchParams.append(`${column}`, `ilike.${pattern}`)\n    return this\n  }\n\n  /**\n   * A check for exact equality (null, true, false), finds all rows whose\n   * value on the stated `column` exactly match the specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  is(column: keyof T, value: boolean | null): this {\n    this.url.searchParams.append(`${column}`, `is.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value on the stated `column` is found on the\n   * specified `values`.\n   *\n   * @param column  The column to filter on.\n   * @param values  The values to filter with.\n   */\n  in(column: keyof T, values: T[keyof T][]): this {\n    const cleanedValues = values\n      .map((s) => {\n        // handle postgrest reserved characters\n        // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n        if (typeof s === 'string' && new RegExp('[,()]').test(s)) return `\"${s}\"`\n        else return `${s}`\n      })\n      .join(',')\n    this.url.searchParams.append(`${column}`, `in.(${cleanedValues})`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose json, array, or range value on the stated `column`\n   * contains the values specified in `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  contains(column: keyof T, value: string | T[keyof T][] | object): this {\n    if (typeof value === 'string') {\n      // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n      // keep it simple and accept a string\n      this.url.searchParams.append(`${column}`, `cs.${value}`)\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(`${column}`, `cs.{${value.join(',')}}`)\n    } else {\n      // json\n      this.url.searchParams.append(`${column}`, `cs.${JSON.stringify(value)}`)\n    }\n    return this\n  }\n\n  /** @deprecated Use `contains()` instead. */\n  cs = this.contains\n\n  /**\n   * Finds all rows whose json, array, or range value on the stated `column` is\n   * contained by the specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  containedBy(column: keyof T, value: string | T[keyof T][] | object): this {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(`${column}`, `cd.${value}`)\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(`${column}`, `cd.{${value.join(',')}}`)\n    } else {\n      // json\n      this.url.searchParams.append(`${column}`, `cd.${JSON.stringify(value)}`)\n    }\n    return this\n  }\n\n  /** @deprecated Use `containedBy()` instead. */\n  cd = this.containedBy\n\n  /**\n   * Finds all rows whose range value on the stated `column` is strictly to the\n   * left of the specified `range`.\n   *\n   * @param column  The column to filter on.\n   * @param range  The range to filter with.\n   */\n  rangeLt(column: keyof T, range: string): this {\n    this.url.searchParams.append(`${column}`, `sl.${range}`)\n    return this\n  }\n\n  /** @deprecated Use `rangeLt()` instead. */\n  sl = this.rangeLt\n\n  /**\n   * Finds all rows whose range value on the stated `column` is strictly to\n   * the right of the specified `range`.\n   *\n   * @param column  The column to filter on.\n   * @param range  The range to filter with.\n   */\n  rangeGt(column: keyof T, range: string): this {\n    this.url.searchParams.append(`${column}`, `sr.${range}`)\n    return this\n  }\n\n  /** @deprecated Use `rangeGt()` instead. */\n  sr = this.rangeGt\n\n  /**\n   * Finds all rows whose range value on the stated `column` does not extend\n   * to the left of the specified `range`.\n   *\n   * @param column  The column to filter on.\n   * @param range  The range to filter with.\n   */\n  rangeGte(column: keyof T, range: string): this {\n    this.url.searchParams.append(`${column}`, `nxl.${range}`)\n    return this\n  }\n\n  /** @deprecated Use `rangeGte()` instead. */\n  nxl = this.rangeGte\n\n  /**\n   * Finds all rows whose range value on the stated `column` does not extend\n   * to the right of the specified `range`.\n   *\n   * @param column  The column to filter on.\n   * @param range  The range to filter with.\n   */\n  rangeLte(column: keyof T, range: string): this {\n    this.url.searchParams.append(`${column}`, `nxr.${range}`)\n    return this\n  }\n\n  /** @deprecated Use `rangeLte()` instead. */\n  nxr = this.rangeLte\n\n  /**\n   * Finds all rows whose range value on the stated `column` is adjacent to\n   * the specified `range`.\n   *\n   * @param column  The column to filter on.\n   * @param range  The range to filter with.\n   */\n  rangeAdjacent(column: keyof T, range: string): this {\n    this.url.searchParams.append(`${column}`, `adj.${range}`)\n    return this\n  }\n\n  /** @deprecated Use `rangeAdjacent()` instead. */\n  adj = this.rangeAdjacent\n\n  /**\n   * Finds all rows whose array or range value on the stated `column` overlaps\n   * (has a value in common) with the specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  overlaps(column: keyof T, value: string | T[keyof T][]): this {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(`${column}`, `ov.${value}`)\n    } else {\n      // array\n      this.url.searchParams.append(`${column}`, `ov.{${value.join(',')}}`)\n    }\n    return this\n  }\n\n  /** @deprecated Use `overlaps()` instead. */\n  ov = this.overlaps\n\n  /**\n   * Finds all rows whose text or tsvector value on the stated `column` matches\n   * the tsquery in `query`.\n   *\n   * @param column  The column to filter on.\n   * @param query  The Postgres tsquery string to filter with.\n   * @param config  The text search configuration to use.\n   * @param type  The type of tsquery conversion to use on `query`.\n   */\n  textSearch(\n    column: keyof T,\n    query: string,\n    {\n      config,\n      type = null,\n    }: { config?: string; type?: 'plain' | 'phrase' | 'websearch' | null } = {}\n  ): this {\n    let typePart = ''\n    if (type === 'plain') {\n      typePart = 'pl'\n    } else if (type === 'phrase') {\n      typePart = 'ph'\n    } else if (type === 'websearch') {\n      typePart = 'w'\n    }\n    const configPart = config === undefined ? '' : `(${config})`\n    this.url.searchParams.append(`${column}`, `${typePart}fts${configPart}.${query}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose tsvector value on the stated `column` matches\n   * to_tsquery(`query`).\n   *\n   * @param column  The column to filter on.\n   * @param query  The Postgres tsquery string to filter with.\n   * @param config  The text search configuration to use.\n   *\n   * @deprecated Use `textSearch()` instead.\n   */\n  fts(column: keyof T, query: string, { config }: { config?: string } = {}): this {\n    const configPart = typeof config === 'undefined' ? '' : `(${config})`\n    this.url.searchParams.append(`${column}`, `fts${configPart}.${query}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose tsvector value on the stated `column` matches\n   * plainto_tsquery(`query`).\n   *\n   * @param column  The column to filter on.\n   * @param query  The Postgres tsquery string to filter with.\n   * @param config  The text search configuration to use.\n   *\n   * @deprecated Use `textSearch()` with `type: 'plain'` instead.\n   */\n  plfts(column: keyof T, query: string, { config }: { config?: string } = {}): this {\n    const configPart = typeof config === 'undefined' ? '' : `(${config})`\n    this.url.searchParams.append(`${column}`, `plfts${configPart}.${query}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose tsvector value on the stated `column` matches\n   * phraseto_tsquery(`query`).\n   *\n   * @param column  The column to filter on.\n   * @param query  The Postgres tsquery string to filter with.\n   * @param config  The text search configuration to use.\n   *\n   * @deprecated Use `textSearch()` with `type: 'phrase'` instead.\n   */\n  phfts(column: keyof T, query: string, { config }: { config?: string } = {}): this {\n    const configPart = typeof config === 'undefined' ? '' : `(${config})`\n    this.url.searchParams.append(`${column}`, `phfts${configPart}.${query}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose tsvector value on the stated `column` matches\n   * websearch_to_tsquery(`query`).\n   *\n   * @param column  The column to filter on.\n   * @param query  The Postgres tsquery string to filter with.\n   * @param config  The text search configuration to use.\n   *\n   * @deprecated Use `textSearch()` with `type: 'websearch'` instead.\n   */\n  wfts(column: keyof T, query: string, { config }: { config?: string } = {}): this {\n    const configPart = typeof config === 'undefined' ? '' : `(${config})`\n    this.url.searchParams.append(`${column}`, `wfts${configPart}.${query}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose `column` satisfies the filter.\n   *\n   * @param column  The column to filter on.\n   * @param operator  The operator to filter with.\n   * @param value  The value to filter with.\n   */\n  filter(column: keyof T, operator: FilterOperator, value: any): this {\n    this.url.searchParams.append(`${column}`, `${operator}.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose columns match the specified `query` object.\n   *\n   * @param query  The object to filter with, with column names as keys mapped\n   *               to their filter values.\n   */\n  match(query: Record<string, unknown>): this {\n    Object.keys(query).forEach((key) => {\n      this.url.searchParams.append(`${key}`, `eq.${query[key]}`)\n    })\n    return this\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}