{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { w3cwebsocket } from 'websocket';\nimport { VSN, CHANNEL_EVENTS, TRANSPORTS, SOCKET_STATES, DEFAULT_TIMEOUT, WS_CLOSE_NORMAL, DEFAULT_HEADERS, CONNECTION_STATE } from './lib/constants';\nimport Timer from './lib/timer';\nimport Serializer from './lib/serializer';\nimport RealtimeSubscription from './RealtimeSubscription';\nimport RealtimeChannel from './RealtimeChannel';\nconst noop = () => {};\nexport default class RealtimeClient {\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.longpollerTimeout The maximum timeout of a long poll AJAX request. Defaults to 20s (double the server long poll timer).\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   */\n  constructor(endPoint, options) {\n    this.accessToken = null;\n    this.channels = [];\n    this.endPoint = '';\n    this.headers = DEFAULT_HEADERS;\n    this.params = {};\n    this.timeout = DEFAULT_TIMEOUT;\n    this.transport = w3cwebsocket;\n    this.heartbeatIntervalMs = 30000;\n    this.longpollerTimeout = 20000;\n    this.heartbeatTimer = undefined;\n    this.pendingHeartbeatRef = null;\n    this.ref = 0;\n    this.logger = noop;\n    this.conn = null;\n    this.sendBuffer = [];\n    this.serializer = new Serializer();\n    this.stateChangeCallbacks = {\n      open: [],\n      close: [],\n      error: [],\n      message: []\n    };\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n    if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n    if (options === null || options === void 0 ? void 0 : options.headers) this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n    if (options === null || options === void 0 ? void 0 : options.timeout) this.timeout = options.timeout;\n    if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n    if (options === null || options === void 0 ? void 0 : options.transport) this.transport = options.transport;\n    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n    if (options === null || options === void 0 ? void 0 : options.longpollerTimeout) this.longpollerTimeout = options.longpollerTimeout;\n    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : tries => {\n      return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n    };\n    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : (payload, callback) => {\n      return callback(JSON.stringify(payload));\n    };\n    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);\n    this.reconnectTimer = new Timer(() => __awaiter(this, void 0, void 0, function* () {\n      yield this.disconnect();\n      this.connect();\n    }), this.reconnectAfterMs);\n  }\n  /**\n   * Connects the socket, unless already connected.\n   */\n  connect() {\n    if (this.conn) {\n      return;\n    }\n    this.conn = new this.transport(this.endPointURL(), [], null, this.headers);\n    if (this.conn) {\n      // this.conn.timeout = this.longpollerTimeout // TYPE ERROR\n      this.conn.binaryType = 'arraybuffer';\n      this.conn.onopen = () => this._onConnOpen();\n      this.conn.onerror = error => this._onConnError(error);\n      this.conn.onmessage = event => this.onConnMessage(event);\n      this.conn.onclose = event => this._onConnClose(event);\n    }\n  }\n  /**\n   * Disconnects the socket.\n   *\n   * @param code A numeric status code to send on disconnect.\n   * @param reason A custom reason for the disconnect.\n   */\n  disconnect(code, reason) {\n    return new Promise((resolve, _reject) => {\n      try {\n        if (this.conn) {\n          this.conn.onclose = function () {}; // noop\n          if (code) {\n            this.conn.close(code, reason || '');\n          } else {\n            this.conn.close();\n          }\n          this.conn = null;\n          // remove open handles\n          this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n          this.reconnectTimer.reset();\n        }\n        resolve({\n          error: null,\n          data: true\n        });\n      } catch (error) {\n        resolve({\n          error: error,\n          data: false\n        });\n      }\n    });\n  }\n  /**\n   * Logs the message.\n   *\n   * For customized logging, `this.logger` can be overriden.\n   */\n  log(kind, msg, data) {\n    this.logger(kind, msg, data);\n  }\n  /**\n   * Registers a callback for connection state change event.\n   *\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onOpen(() => console.log(\"Socket opened.\"))\n   */\n  onOpen(callback) {\n    this.stateChangeCallbacks.open.push(callback);\n  }\n  /**\n   * Registers a callback for connection state change events.\n   *\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onOpen(() => console.log(\"Socket closed.\"))\n   */\n  onClose(callback) {\n    this.stateChangeCallbacks.close.push(callback);\n  }\n  /**\n   * Registers a callback for connection state change events.\n   *\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onOpen((error) => console.log(\"An error occurred\"))\n   */\n  onError(callback) {\n    this.stateChangeCallbacks.error.push(callback);\n  }\n  /**\n   * Calls a function any time a message is received.\n   *\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onMessage((message) => console.log(message))\n   */\n  onMessage(callback) {\n    this.stateChangeCallbacks.message.push(callback);\n  }\n  /**\n   * Returns the current state of the socket.\n   */\n  connectionState() {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting;\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open;\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing;\n      default:\n        return CONNECTION_STATE.Closed;\n    }\n  }\n  /**\n   * Retuns `true` is the connection is open.\n   */\n  isConnected() {\n    return this.connectionState() === CONNECTION_STATE.Open;\n  }\n  /**\n   * Removes a subscription from the socket.\n   *\n   * @param channel An open subscription.\n   */\n  remove(channel) {\n    this.channels = this.channels.filter(c => c.joinRef() !== channel.joinRef());\n  }\n  channel(topic) {\n    let chanParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a;\n    const {\n        selfBroadcast\n      } = chanParams,\n      params = __rest(chanParams, [\"selfBroadcast\"]);\n    if (selfBroadcast) {\n      params.self_broadcast = selfBroadcast;\n    }\n    const chan = ((_a = this.params) === null || _a === void 0 ? void 0 : _a.vsndate) ? new RealtimeChannel(topic, params, this) : new RealtimeSubscription(topic, params, this);\n    if (chan instanceof RealtimeChannel) {\n      chan.presence.onJoin((key, currentPresences, newPresences) => {\n        chan.trigger('presence', {\n          event: 'JOIN',\n          key,\n          currentPresences,\n          newPresences\n        });\n      });\n      chan.presence.onLeave((key, currentPresences, leftPresences) => {\n        chan.trigger('presence', {\n          event: 'LEAVE',\n          key,\n          currentPresences,\n          leftPresences\n        });\n      });\n      chan.presence.onSync(() => {\n        chan.trigger('presence', {\n          event: 'SYNC'\n        });\n      });\n    }\n    this.channels.push(chan);\n    return chan;\n  }\n  /**\n   * Push out a message if the socket is connected.\n   *\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n   */\n  push(data) {\n    const {\n      topic,\n      event,\n      payload,\n      ref\n    } = data;\n    let callback = () => {\n      this.encode(data, result => {\n        var _a;\n        (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n      });\n    };\n    this.log('push', `${topic} ${event} (${ref})`, payload);\n    if (this.isConnected()) {\n      callback();\n    } else {\n      this.sendBuffer.push(callback);\n    }\n  }\n  onConnMessage(rawMessage) {\n    this.decode(rawMessage.data, msg => {\n      let {\n        topic,\n        event,\n        payload,\n        ref\n      } = msg;\n      if (ref && ref === this.pendingHeartbeatRef || event === (payload === null || payload === void 0 ? void 0 : payload.type)) {\n        this.pendingHeartbeatRef = null;\n      }\n      this.log('receive', `${payload.status || ''} ${topic} ${event} ${ref && '(' + ref + ')' || ''}`, payload);\n      this.channels.filter(channel => channel.isMember(topic)).forEach(channel => channel.trigger(event, payload, ref));\n      this.stateChangeCallbacks.message.forEach(callback => callback(msg));\n    });\n  }\n  /**\n   * Returns the URL of the websocket.\n   */\n  endPointURL() {\n    return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n      vsn: VSN\n    }));\n  }\n  /**\n   * Return the next message ref, accounting for overflows\n   */\n  makeRef() {\n    let newRef = this.ref + 1;\n    if (newRef === this.ref) {\n      this.ref = 0;\n    } else {\n      this.ref = newRef;\n    }\n    return this.ref.toString();\n  }\n  /**\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n   *\n   * @param token A JWT string.\n   */\n  setAuth(token) {\n    this.accessToken = token;\n    this.channels.forEach(channel => {\n      token && channel.updateJoinPayload({\n        user_token: token\n      });\n      if (channel.joinedOnce && channel.isJoined()) {\n        channel.push(CHANNEL_EVENTS.access_token, {\n          access_token: token\n        });\n      }\n    });\n  }\n  /**\n   * Unsubscribe from channels with the specified topic.\n   */\n  leaveOpenTopic(topic) {\n    let dupChannel = this.channels.find(c => c.topic === topic && (c.isJoined() || c.isJoining()));\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`);\n      dupChannel.unsubscribe();\n    }\n  }\n  _onConnOpen() {\n    this.log('transport', `connected to ${this.endPointURL()}`);\n    this._flushSendBuffer();\n    this.reconnectTimer.reset();\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n    this.heartbeatTimer = setInterval(() => this._sendHeartbeat(), this.heartbeatIntervalMs);\n    this.stateChangeCallbacks.open.forEach(callback => callback());\n  }\n  _onConnClose(event) {\n    this.log('transport', 'close', event);\n    this._triggerChanError();\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n    this.reconnectTimer.scheduleTimeout();\n    this.stateChangeCallbacks.close.forEach(callback => callback(event));\n  }\n  _onConnError(error) {\n    this.log('transport', error.message);\n    this._triggerChanError();\n    this.stateChangeCallbacks.error.forEach(callback => callback(error));\n  }\n  _triggerChanError() {\n    this.channels.forEach(channel => channel.trigger(CHANNEL_EVENTS.error));\n  }\n  _appendParams(url, params) {\n    if (Object.keys(params).length === 0) {\n      return url;\n    }\n    const prefix = url.match(/\\?/) ? '&' : '?';\n    const query = new URLSearchParams(params);\n    return `${url}${prefix}${query}`;\n  }\n  _flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach(callback => callback());\n      this.sendBuffer = [];\n    }\n  }\n  _sendHeartbeat() {\n    var _a;\n    if (!this.isConnected()) {\n      return;\n    }\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null;\n      this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n      (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n      return;\n    }\n    this.pendingHeartbeatRef = this.makeRef();\n    this.push({\n      topic: 'phoenix',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef\n    });\n    this.setAuth(this.accessToken);\n  }\n}","map":{"version":3,"names":["w3cwebsocket","VSN","CHANNEL_EVENTS","TRANSPORTS","SOCKET_STATES","DEFAULT_TIMEOUT","WS_CLOSE_NORMAL","DEFAULT_HEADERS","CONNECTION_STATE","Timer","Serializer","RealtimeSubscription","RealtimeChannel","noop","RealtimeClient","constructor","endPoint","options","accessToken","channels","headers","params","timeout","transport","heartbeatIntervalMs","longpollerTimeout","heartbeatTimer","undefined","pendingHeartbeatRef","ref","logger","conn","sendBuffer","serializer","stateChangeCallbacks","open","close","error","message","websocket","Object","assign","reconnectAfterMs","tries","encode","payload","callback","JSON","stringify","decode","bind","reconnectTimer","__awaiter","disconnect","connect","endPointURL","binaryType","onopen","_onConnOpen","onerror","_onConnError","onmessage","event","onConnMessage","onclose","_onConnClose","code","reason","Promise","resolve","_reject","clearInterval","reset","data","log","kind","msg","onOpen","push","onClose","onError","onMessage","connectionState","readyState","connecting","Connecting","Open","closing","Closing","Closed","isConnected","remove","channel","filter","c","joinRef","topic","chanParams","arguments","length","selfBroadcast","__rest","self_broadcast","chan","_a","vsndate","presence","onJoin","key","currentPresences","newPresences","trigger","onLeave","leftPresences","onSync","result","send","rawMessage","type","status","isMember","forEach","_appendParams","vsn","makeRef","newRef","toString","setAuth","token","updateJoinPayload","user_token","joinedOnce","isJoined","access_token","leaveOpenTopic","dupChannel","find","isJoining","unsubscribe","_flushSendBuffer","setInterval","_sendHeartbeat","_triggerChanError","scheduleTimeout","url","keys","prefix","match","query","URLSearchParams"],"sources":["/Users/mako/Downloads/supabase-todo-main/node_modules/@supabase/realtime-js/src/RealtimeClient.ts"],"sourcesContent":["import { w3cwebsocket } from 'websocket'\nimport {\n  VSN,\n  CHANNEL_EVENTS,\n  TRANSPORTS,\n  SOCKET_STATES,\n  DEFAULT_TIMEOUT,\n  WS_CLOSE_NORMAL,\n  DEFAULT_HEADERS,\n  CONNECTION_STATE,\n} from './lib/constants'\nimport Timer from './lib/timer'\nimport Serializer from './lib/serializer'\nimport RealtimeSubscription from './RealtimeSubscription'\nimport RealtimeChannel from './RealtimeChannel'\n\nexport type Options = {\n  transport?: WebSocket\n  timeout?: number\n  heartbeatIntervalMs?: number\n  longpollerTimeout?: number\n  logger?: Function\n  encode?: Function\n  decode?: Function\n  reconnectAfterMs?: Function\n  headers?: { [key: string]: string }\n  params?: { [key: string]: string }\n}\ntype Message = {\n  topic: string\n  event: string\n  payload: any\n  ref: string\n}\n\ntype ChannelParams = {\n  selfBroadcast?: boolean\n  [key: string]: any\n}\n\nconst noop = () => {}\n\nexport default class RealtimeClient {\n  accessToken: string | null = null\n  channels: (RealtimeSubscription | RealtimeChannel)[] = []\n  endPoint: string = ''\n  headers?: { [key: string]: string } = DEFAULT_HEADERS\n  params?: { [key: string]: string } = {}\n  timeout: number = DEFAULT_TIMEOUT\n  transport: any = w3cwebsocket\n  heartbeatIntervalMs: number = 30000\n  longpollerTimeout: number = 20000\n  heartbeatTimer: ReturnType<typeof setInterval> | undefined = undefined\n  pendingHeartbeatRef: string | null = null\n  ref: number = 0\n  reconnectTimer: Timer\n  logger: Function = noop\n  encode: Function\n  decode: Function\n  reconnectAfterMs: Function\n  conn: WebSocket | null = null\n  sendBuffer: Function[] = []\n  serializer: Serializer = new Serializer()\n  stateChangeCallbacks: {\n    open: Function[]\n    close: Function[]\n    error: Function[]\n    message: Function[]\n  } = {\n    open: [],\n    close: [],\n    error: [],\n    message: [],\n  }\n\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.longpollerTimeout The maximum timeout of a long poll AJAX request. Defaults to 20s (double the server long poll timer).\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   */\n  constructor(endPoint: string, options?: Options) {\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`\n\n    if (options?.params) this.params = options.params\n    if (options?.headers) this.headers = { ...this.headers, ...options.headers }\n    if (options?.timeout) this.timeout = options.timeout\n    if (options?.logger) this.logger = options.logger\n    if (options?.transport) this.transport = options.transport\n    if (options?.heartbeatIntervalMs)\n      this.heartbeatIntervalMs = options.heartbeatIntervalMs\n    if (options?.longpollerTimeout)\n      this.longpollerTimeout = options.longpollerTimeout\n\n    this.reconnectAfterMs = options?.reconnectAfterMs\n      ? options.reconnectAfterMs\n      : (tries: number) => {\n          return [1000, 2000, 5000, 10000][tries - 1] || 10000\n        }\n    this.encode = options?.encode\n      ? options.encode\n      : (payload: JSON, callback: Function) => {\n          return callback(JSON.stringify(payload))\n        }\n    this.decode = options?.decode\n      ? options.decode\n      : this.serializer.decode.bind(this.serializer)\n    this.reconnectTimer = new Timer(async () => {\n      await this.disconnect()\n      this.connect()\n    }, this.reconnectAfterMs)\n  }\n\n  /**\n   * Connects the socket, unless already connected.\n   */\n  connect(): void {\n    if (this.conn) {\n      return\n    }\n\n    this.conn = new this.transport(this.endPointURL(), [], null, this.headers)\n\n    if (this.conn) {\n      // this.conn.timeout = this.longpollerTimeout // TYPE ERROR\n      this.conn.binaryType = 'arraybuffer'\n      this.conn.onopen = () => this._onConnOpen()\n      this.conn.onerror = (error) => this._onConnError(error as ErrorEvent)\n      this.conn.onmessage = (event) => this.onConnMessage(event)\n      this.conn.onclose = (event) => this._onConnClose(event)\n    }\n  }\n\n  /**\n   * Disconnects the socket.\n   *\n   * @param code A numeric status code to send on disconnect.\n   * @param reason A custom reason for the disconnect.\n   */\n  disconnect(\n    code?: number,\n    reason?: string\n  ): Promise<{ error: Error | null; data: boolean }> {\n    return new Promise((resolve, _reject) => {\n      try {\n        if (this.conn) {\n          this.conn.onclose = function () {} // noop\n          if (code) {\n            this.conn.close(code, reason || '')\n          } else {\n            this.conn.close()\n          }\n          this.conn = null\n          // remove open handles\n          this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n          this.reconnectTimer.reset()\n        }\n        resolve({ error: null, data: true })\n      } catch (error) {\n        resolve({ error: error as Error, data: false })\n      }\n    })\n  }\n\n  /**\n   * Logs the message.\n   *\n   * For customized logging, `this.logger` can be overriden.\n   */\n  log(kind: string, msg: string, data?: any) {\n    this.logger(kind, msg, data)\n  }\n\n  /**\n   * Registers a callback for connection state change event.\n   *\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onOpen(() => console.log(\"Socket opened.\"))\n   */\n  onOpen(callback: Function) {\n    this.stateChangeCallbacks.open.push(callback)\n  }\n\n  /**\n   * Registers a callback for connection state change events.\n   *\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onOpen(() => console.log(\"Socket closed.\"))\n   */\n  onClose(callback: Function) {\n    this.stateChangeCallbacks.close.push(callback)\n  }\n\n  /**\n   * Registers a callback for connection state change events.\n   *\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onOpen((error) => console.log(\"An error occurred\"))\n   */\n  onError(callback: Function) {\n    this.stateChangeCallbacks.error.push(callback)\n  }\n\n  /**\n   * Calls a function any time a message is received.\n   *\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onMessage((message) => console.log(message))\n   */\n  onMessage(callback: Function) {\n    this.stateChangeCallbacks.message.push(callback)\n  }\n\n  /**\n   * Returns the current state of the socket.\n   */\n  connectionState(): CONNECTION_STATE {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing\n      default:\n        return CONNECTION_STATE.Closed\n    }\n  }\n\n  /**\n   * Retuns `true` is the connection is open.\n   */\n  isConnected(): boolean {\n    return this.connectionState() === CONNECTION_STATE.Open\n  }\n\n  /**\n   * Removes a subscription from the socket.\n   *\n   * @param channel An open subscription.\n   */\n  remove(channel: RealtimeSubscription | RealtimeChannel) {\n    this.channels = this.channels.filter(\n      (c: RealtimeSubscription | RealtimeChannel) =>\n        c.joinRef() !== channel.joinRef()\n    )\n  }\n\n  channel(\n    topic: string,\n    chanParams: ChannelParams = {}\n  ): RealtimeChannel | RealtimeSubscription {\n    const { selfBroadcast, ...params } = chanParams\n\n    if (selfBroadcast) {\n      params.self_broadcast = selfBroadcast\n    }\n\n    const chan = this.params?.vsndate\n      ? new RealtimeChannel(topic, params, this)\n      : new RealtimeSubscription(topic, params, this)\n\n    if (chan instanceof RealtimeChannel) {\n      chan.presence.onJoin((key, currentPresences, newPresences) => {\n        chan.trigger('presence', {\n          event: 'JOIN',\n          key,\n          currentPresences,\n          newPresences,\n        })\n      })\n\n      chan.presence.onLeave((key, currentPresences, leftPresences) => {\n        chan.trigger('presence', {\n          event: 'LEAVE',\n          key,\n          currentPresences,\n          leftPresences,\n        })\n      })\n\n      chan.presence.onSync(() => {\n        chan.trigger('presence', { event: 'SYNC' })\n      })\n    }\n\n    this.channels.push(chan)\n    return chan\n  }\n\n  /**\n   * Push out a message if the socket is connected.\n   *\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n   */\n  push(data: Message): void {\n    const { topic, event, payload, ref } = data\n    let callback = () => {\n      this.encode(data, (result: any) => {\n        this.conn?.send(result)\n      })\n    }\n    this.log('push', `${topic} ${event} (${ref})`, payload)\n    if (this.isConnected()) {\n      callback()\n    } else {\n      this.sendBuffer.push(callback)\n    }\n  }\n\n  onConnMessage(rawMessage: { data: any }) {\n    this.decode(rawMessage.data, (msg: Message) => {\n      let { topic, event, payload, ref } = msg\n\n      if (\n        (ref && ref === this.pendingHeartbeatRef) ||\n        event === payload?.type\n      ) {\n        this.pendingHeartbeatRef = null\n      }\n\n      this.log(\n        'receive',\n        `${payload.status || ''} ${topic} ${event} ${\n          (ref && '(' + ref + ')') || ''\n        }`,\n        payload\n      )\n      this.channels\n        .filter((channel: RealtimeSubscription | RealtimeChannel) =>\n          channel.isMember(topic)\n        )\n        .forEach((channel: RealtimeSubscription | RealtimeChannel) =>\n          channel.trigger(event, payload, ref)\n        )\n      this.stateChangeCallbacks.message.forEach((callback) => callback(msg))\n    })\n  }\n\n  /**\n   * Returns the URL of the websocket.\n   */\n  endPointURL(): string {\n    return this._appendParams(\n      this.endPoint,\n      Object.assign({}, this.params, { vsn: VSN })\n    )\n  }\n\n  /**\n   * Return the next message ref, accounting for overflows\n   */\n  makeRef(): string {\n    let newRef = this.ref + 1\n    if (newRef === this.ref) {\n      this.ref = 0\n    } else {\n      this.ref = newRef\n    }\n\n    return this.ref.toString()\n  }\n\n  /**\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n   *\n   * @param token A JWT string.\n   */\n  setAuth(token: string | null) {\n    this.accessToken = token\n\n    this.channels.forEach((channel) => {\n      token && channel.updateJoinPayload({ user_token: token })\n\n      if (channel.joinedOnce && channel.isJoined()) {\n        channel.push(CHANNEL_EVENTS.access_token, { access_token: token })\n      }\n    })\n  }\n\n  /**\n   * Unsubscribe from channels with the specified topic.\n   */\n  leaveOpenTopic(topic: string): void {\n    let dupChannel = this.channels.find(\n      (c) => c.topic === topic && (c.isJoined() || c.isJoining())\n    )\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`)\n      dupChannel.unsubscribe()\n    }\n  }\n\n  private _onConnOpen() {\n    this.log('transport', `connected to ${this.endPointURL()}`)\n    this._flushSendBuffer()\n    this.reconnectTimer.reset()\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.heartbeatTimer = setInterval(\n      () => this._sendHeartbeat(),\n      this.heartbeatIntervalMs\n    )\n    this.stateChangeCallbacks.open.forEach((callback) => callback())!\n  }\n\n  private _onConnClose(event: any) {\n    this.log('transport', 'close', event)\n    this._triggerChanError()\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.reconnectTimer.scheduleTimeout()\n    this.stateChangeCallbacks.close.forEach((callback) => callback(event))\n  }\n\n  private _onConnError(error: ErrorEvent) {\n    this.log('transport', error.message)\n    this._triggerChanError()\n    this.stateChangeCallbacks.error.forEach((callback) => callback(error))\n  }\n\n  private _triggerChanError() {\n    this.channels.forEach((channel: RealtimeSubscription | RealtimeChannel) =>\n      channel.trigger(CHANNEL_EVENTS.error)\n    )\n  }\n\n  private _appendParams(\n    url: string,\n    params: { [key: string]: string }\n  ): string {\n    if (Object.keys(params).length === 0) {\n      return url\n    }\n    const prefix = url.match(/\\?/) ? '&' : '?'\n    const query = new URLSearchParams(params)\n\n    return `${url}${prefix}${query}`\n  }\n\n  private _flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach((callback) => callback())\n      this.sendBuffer = []\n    }\n  }\n\n  private _sendHeartbeat() {\n    if (!this.isConnected()) {\n      return\n    }\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null\n      this.log(\n        'transport',\n        'heartbeat timeout. Attempting to re-establish connection'\n      )\n      this.conn?.close(WS_CLOSE_NORMAL, 'hearbeat timeout')\n      return\n    }\n    this.pendingHeartbeatRef = this.makeRef()\n    this.push({\n      topic: 'phoenix',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef,\n    })\n    this.setAuth(this.accessToken)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}