{"ast":null,"code":"import _regeneratorRuntime from \"/Users/mako/Downloads/todo_supabase/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"/Users/mako/Downloads/todo_supabase/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/mako/Downloads/todo_supabase/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport GoTrueApi from './GoTrueApi';\nimport { isBrowser, getParameterByName, uuid, setItemAsync, removeItemAsync, getItemSynchronously, getItemAsync } from './lib/helpers';\nimport { GOTRUE_URL, DEFAULT_HEADERS, STORAGE_KEY, EXPIRY_MARGIN, NETWORK_FAILURE } from './lib/constants';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\nvar DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  multiTab: true,\n  headers: DEFAULT_HEADERS\n};\nvar decodeBase64URL = function decodeBase64URL(value) {\n  try {\n    // atob is present in all browsers and nodejs >= 16\n    // but if it is not it will throw a ReferenceError in which case we can try to use Buffer\n    // replace are here to convert the Base64-URL into Base64 which is what atob supports\n    // replace with //g regex acts like replaceAll\n    return atob(value.replace(/[-]/g, '+').replace(/[_]/g, '/'));\n  } catch (e) {\n    if (e instanceof ReferenceError) {\n      // running on nodejs < 16\n      // Buffer supports Base64-URL transparently\n      return Buffer.from(value, 'base64').toString('utf-8');\n    } else {\n      throw e;\n    }\n  }\n};\nvar GoTrueClient = /*#__PURE__*/function () {\n  /**\n   * Create a new client for use in the browser.\n   * @param options.url The URL of the GoTrue server.\n   * @param options.headers Any additional headers to send to the GoTrue server.\n   * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.localStorage Provide your own local storage implementation to use instead of the browser's local storage.\n   * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n   * @param options.cookieOptions\n   * @param options.fetch A custom fetch implementation.\n   */\n  function GoTrueClient(options) {\n    _classCallCheck(this, GoTrueClient);\n    this.stateChangeEmitters = new Map();\n    this.networkRetries = 0;\n    var settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.currentUser = null;\n    this.currentSession = null;\n    this.autoRefreshToken = settings.autoRefreshToken;\n    this.persistSession = settings.persistSession;\n    this.multiTab = settings.multiTab;\n    this.localStorage = settings.localStorage || globalThis.localStorage;\n    this.api = new GoTrueApi({\n      url: settings.url,\n      headers: settings.headers,\n      cookieOptions: settings.cookieOptions,\n      fetch: settings.fetch\n    });\n    this._recoverSession();\n    this._recoverAndRefresh();\n    this._listenForMultiTabEvents();\n    this._handleVisibilityChange();\n    if (settings.detectSessionInUrl && isBrowser() && !!getParameterByName('access_token')) {\n      // Handle the OAuth redirect\n      this.getSessionFromUrl({\n        storeSession: true\n      }).then(function (_ref) {\n        var error = _ref.error;\n        if (error) {\n          throw new Error('Error getting session from URL.');\n        }\n      });\n    }\n  }\n  /**\n   * Creates a new user.\n   * @type UserCredentials\n   * @param email The user's email address.\n   * @param password The user's password.\n   * @param phone The user's phone number.\n   * @param redirectTo The redirect URL attached to the signup confirmation link. Does not redirect the user if it's a mobile signup.\n   * @param data Optional user metadata.\n   */\n  _createClass(GoTrueClient, [{\n    key: \"signUp\",\n    value: function signUp(_ref2) {\n      var email = _ref2.email,\n        password = _ref2.password,\n        phone = _ref2.phone;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _ref3, data, error, session, user;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                this._removeSession();\n                if (!(phone && password)) {\n                  _context.next = 8;\n                  break;\n                }\n                _context.next = 5;\n                return this.api.signUpWithPhone(phone, password, {\n                  data: options.data,\n                  captchaToken: options.captchaToken\n                });\n              case 5:\n                _context.t0 = _context.sent;\n                _context.next = 11;\n                break;\n              case 8:\n                _context.next = 10;\n                return this.api.signUpWithEmail(email, password, {\n                  redirectTo: options.redirectTo,\n                  data: options.data,\n                  captchaToken: options.captchaToken\n                });\n              case 10:\n                _context.t0 = _context.sent;\n              case 11:\n                _ref3 = _context.t0;\n                data = _ref3.data;\n                error = _ref3.error;\n                if (!error) {\n                  _context.next = 16;\n                  break;\n                }\n                throw error;\n              case 16:\n                if (data) {\n                  _context.next = 18;\n                  break;\n                }\n                throw 'An error occurred on sign up.';\n              case 18:\n                session = null;\n                user = null;\n                if (data.access_token) {\n                  session = data;\n                  user = session.user;\n                  this._saveSession(session);\n                  this._notifyAllSubscribers('SIGNED_IN');\n                }\n                if (data.id) {\n                  user = data;\n                }\n                return _context.abrupt(\"return\", {\n                  user: user,\n                  session: session,\n                  error: null\n                });\n              case 25:\n                _context.prev = 25;\n                _context.t1 = _context[\"catch\"](0);\n                return _context.abrupt(\"return\", {\n                  user: null,\n                  session: null,\n                  error: _context.t1\n                });\n              case 28:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 25]]);\n      }));\n    }\n    /**\n     * Log in an existing user, or login via a third-party provider.\n     * @type UserCredentials\n     * @param email The user's email address.\n     * @param phone The user's phone number.\n     * @param password The user's password.\n     * @param refreshToken A valid refresh token that was returned on login.\n     * @param provider One of the providers supported by GoTrue.\n     * @param redirectTo A URL to send the user to after they are confirmed (OAuth logins only).\n     * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n     * @param scopes A space-separated list of scopes granted to the OAuth application.\n     */\n  }, {\n    key: \"signIn\",\n    value: function signIn(_ref4) {\n      var email = _ref4.email,\n        phone = _ref4.phone,\n        password = _ref4.password,\n        refreshToken = _ref4.refreshToken,\n        provider = _ref4.provider,\n        oidc = _ref4.oidc;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _yield$this$api$sendM, error, _yield$this$api$sendM2, _error, _yield$this$_callRefr, _error2;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                this._removeSession();\n                if (!(email && !password)) {\n                  _context2.next = 8;\n                  break;\n                }\n                _context2.next = 5;\n                return this.api.sendMagicLinkEmail(email, {\n                  redirectTo: options.redirectTo,\n                  shouldCreateUser: options.shouldCreateUser,\n                  captchaToken: options.captchaToken\n                });\n              case 5:\n                _yield$this$api$sendM = _context2.sent;\n                error = _yield$this$api$sendM.error;\n                return _context2.abrupt(\"return\", {\n                  user: null,\n                  session: null,\n                  error: error\n                });\n              case 8:\n                if (!(email && password)) {\n                  _context2.next = 10;\n                  break;\n                }\n                return _context2.abrupt(\"return\", this._handleEmailSignIn(email, password, {\n                  redirectTo: options.redirectTo,\n                  captchaToken: options.captchaToken\n                }));\n              case 10:\n                if (!(phone && !password)) {\n                  _context2.next = 16;\n                  break;\n                }\n                _context2.next = 13;\n                return this.api.sendMobileOTP(phone, {\n                  shouldCreateUser: options.shouldCreateUser,\n                  captchaToken: options.captchaToken\n                });\n              case 13:\n                _yield$this$api$sendM2 = _context2.sent;\n                _error = _yield$this$api$sendM2.error;\n                return _context2.abrupt(\"return\", {\n                  user: null,\n                  session: null,\n                  error: _error\n                });\n              case 16:\n                if (!(phone && password)) {\n                  _context2.next = 18;\n                  break;\n                }\n                return _context2.abrupt(\"return\", this._handlePhoneSignIn(phone, password));\n              case 18:\n                if (!refreshToken) {\n                  _context2.next = 26;\n                  break;\n                }\n                _context2.next = 21;\n                return this._callRefreshToken(refreshToken);\n              case 21:\n                _yield$this$_callRefr = _context2.sent;\n                _error2 = _yield$this$_callRefr.error;\n                if (!_error2) {\n                  _context2.next = 25;\n                  break;\n                }\n                throw _error2;\n              case 25:\n                return _context2.abrupt(\"return\", {\n                  user: this.currentUser,\n                  session: this.currentSession,\n                  error: null\n                });\n              case 26:\n                if (!provider) {\n                  _context2.next = 28;\n                  break;\n                }\n                return _context2.abrupt(\"return\", this._handleProviderSignIn(provider, {\n                  redirectTo: options.redirectTo,\n                  scopes: options.scopes,\n                  queryParams: options.queryParams\n                }));\n              case 28:\n                if (!oidc) {\n                  _context2.next = 30;\n                  break;\n                }\n                return _context2.abrupt(\"return\", this._handleOpenIDConnectSignIn(oidc));\n              case 30:\n                throw new Error(\"You must provide either an email, phone number, a third-party provider or OpenID Connect.\");\n              case 33:\n                _context2.prev = 33;\n                _context2.t0 = _context2[\"catch\"](0);\n                return _context2.abrupt(\"return\", {\n                  user: null,\n                  session: null,\n                  error: _context2.t0\n                });\n              case 36:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 33]]);\n      }));\n    }\n    /**\n     * Log in a user given a User supplied OTP received via mobile.\n     * @param email The user's email address.\n     * @param phone The user's phone number.\n     * @param token The user's password.\n     * @param type The user's verification type.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n  }, {\n    key: \"verifyOTP\",\n    value: function verifyOTP(params) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var _yield$this$api$verif, data, error, session, user;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                this._removeSession();\n                _context3.next = 4;\n                return this.api.verifyOTP(params, options);\n              case 4:\n                _yield$this$api$verif = _context3.sent;\n                data = _yield$this$api$verif.data;\n                error = _yield$this$api$verif.error;\n                if (!error) {\n                  _context3.next = 9;\n                  break;\n                }\n                throw error;\n              case 9:\n                if (data) {\n                  _context3.next = 11;\n                  break;\n                }\n                throw 'An error occurred on token verification.';\n              case 11:\n                session = null;\n                user = null;\n                if (data.access_token) {\n                  session = data;\n                  user = session.user;\n                  this._saveSession(session);\n                  this._notifyAllSubscribers('SIGNED_IN');\n                }\n                if (data.id) {\n                  user = data;\n                }\n                return _context3.abrupt(\"return\", {\n                  user: user,\n                  session: session,\n                  error: null\n                });\n              case 18:\n                _context3.prev = 18;\n                _context3.t0 = _context3[\"catch\"](0);\n                return _context3.abrupt(\"return\", {\n                  user: null,\n                  session: null,\n                  error: _context3.t0\n                });\n              case 21:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 18]]);\n      }));\n    }\n    /**\n     * Inside a browser context, `user()` will return the user data, if there is a logged in user.\n     *\n     * For server-side management, you can get a user through `auth.api.getUserByCookie()`\n     */\n  }, {\n    key: \"user\",\n    value: function user() {\n      return this.currentUser;\n    }\n    /**\n     * Returns the session data, if there is an active session.\n     */\n  }, {\n    key: \"session\",\n    value: function session() {\n      return this.currentSession;\n    }\n    /**\n     * Force refreshes the session including the user data in case it was updated in a different session.\n     */\n  }, {\n    key: \"refreshSession\",\n    value: function refreshSession() {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _yield$this$_callRefr2, error;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.prev = 0;\n                if ((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) {\n                  _context4.next = 3;\n                  break;\n                }\n                throw new Error('Not logged in.');\n              case 3:\n                _context4.next = 5;\n                return this._callRefreshToken();\n              case 5:\n                _yield$this$_callRefr2 = _context4.sent;\n                error = _yield$this$_callRefr2.error;\n                if (!error) {\n                  _context4.next = 9;\n                  break;\n                }\n                throw error;\n              case 9:\n                return _context4.abrupt(\"return\", {\n                  data: this.currentSession,\n                  user: this.currentUser,\n                  error: null\n                });\n              case 12:\n                _context4.prev = 12;\n                _context4.t0 = _context4[\"catch\"](0);\n                return _context4.abrupt(\"return\", {\n                  data: null,\n                  user: null,\n                  error: _context4.t0\n                });\n              case 15:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[0, 12]]);\n      }));\n    }\n    /**\n     * Updates user data, if there is a logged in user.\n     */\n  }, {\n    key: \"update\",\n    value: function update(attributes) {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var _yield$this$api$updat, user, error, session;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.prev = 0;\n                if ((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) {\n                  _context5.next = 3;\n                  break;\n                }\n                throw new Error('Not logged in.');\n              case 3:\n                _context5.next = 5;\n                return this.api.updateUser(this.currentSession.access_token, attributes);\n              case 5:\n                _yield$this$api$updat = _context5.sent;\n                user = _yield$this$api$updat.user;\n                error = _yield$this$api$updat.error;\n                if (!error) {\n                  _context5.next = 10;\n                  break;\n                }\n                throw error;\n              case 10:\n                if (user) {\n                  _context5.next = 12;\n                  break;\n                }\n                throw Error('Invalid user data.');\n              case 12:\n                session = Object.assign(Object.assign({}, this.currentSession), {\n                  user: user\n                });\n                this._saveSession(session);\n                this._notifyAllSubscribers('USER_UPDATED');\n                return _context5.abrupt(\"return\", {\n                  data: user,\n                  user: user,\n                  error: null\n                });\n              case 18:\n                _context5.prev = 18;\n                _context5.t0 = _context5[\"catch\"](0);\n                return _context5.abrupt(\"return\", {\n                  data: null,\n                  user: null,\n                  error: _context5.t0\n                });\n              case 21:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[0, 18]]);\n      }));\n    }\n  }, {\n    key: \"setSession\",\n    value: function setSession(arg0) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var session, refresh_token, _yield$this$api$refre, data, error, timeNow, _refresh_token, access_token, expires_at, expires_in, tokenParts, bodyJSON, parsed, _yield$this$api$refre2, _data, _error3, _yield$this$api$getUs, user, _error4;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!(typeof arg0 === 'string')) {\n                  _context6.next = 12;\n                  break;\n                }\n                // using the refresh_token string API\n                refresh_token = arg0;\n                _context6.next = 4;\n                return this.api.refreshAccessToken(refresh_token);\n              case 4:\n                _yield$this$api$refre = _context6.sent;\n                data = _yield$this$api$refre.data;\n                error = _yield$this$api$refre.error;\n                if (!error) {\n                  _context6.next = 9;\n                  break;\n                }\n                return _context6.abrupt(\"return\", {\n                  session: null,\n                  error: error\n                });\n              case 9:\n                session = data;\n                _context6.next = 53;\n                break;\n              case 12:\n                // using the object parameter API\n                timeNow = Math.round(Date.now() / 1000);\n                _refresh_token = arg0.refresh_token, access_token = arg0.access_token;\n                expires_at = 0;\n                expires_in = 0;\n                tokenParts = access_token.split('.');\n                if (!(tokenParts.length !== 3)) {\n                  _context6.next = 19;\n                  break;\n                }\n                throw new Error('access_token is not a proper JWT');\n              case 19:\n                bodyJSON = decodeBase64URL(tokenParts[1]);\n                parsed = undefined;\n                _context6.prev = 21;\n                parsed = JSON.parse(bodyJSON);\n                _context6.next = 28;\n                break;\n              case 25:\n                _context6.prev = 25;\n                _context6.t0 = _context6[\"catch\"](21);\n                throw new Error('access_token is not a proper JWT, invalid JSON in body');\n              case 28:\n                if (!(typeof parsed === 'object' && parsed && typeof parsed.exp === 'number')) {\n                  _context6.next = 33;\n                  break;\n                }\n                expires_at = parsed.exp;\n                expires_in = timeNow - parsed.exp;\n                _context6.next = 34;\n                break;\n              case 33:\n                throw new Error('access_token is not a proper JWT, missing exp claim');\n              case 34:\n                if (!(timeNow > expires_at)) {\n                  _context6.next = 45;\n                  break;\n                }\n                _context6.next = 37;\n                return this.api.refreshAccessToken(_refresh_token);\n              case 37:\n                _yield$this$api$refre2 = _context6.sent;\n                _data = _yield$this$api$refre2.data;\n                _error3 = _yield$this$api$refre2.error;\n                if (!_error3) {\n                  _context6.next = 42;\n                  break;\n                }\n                return _context6.abrupt(\"return\", {\n                  session: null,\n                  error: _error3\n                });\n              case 42:\n                session = _data;\n                _context6.next = 53;\n                break;\n              case 45:\n                _context6.next = 47;\n                return this.api.getUser(access_token);\n              case 47:\n                _yield$this$api$getUs = _context6.sent;\n                user = _yield$this$api$getUs.user;\n                _error4 = _yield$this$api$getUs.error;\n                if (!_error4) {\n                  _context6.next = 52;\n                  break;\n                }\n                throw _error4;\n              case 52:\n                session = {\n                  access_token: access_token,\n                  expires_in: expires_in,\n                  expires_at: expires_at,\n                  refresh_token: _refresh_token,\n                  token_type: 'bearer',\n                  user: user\n                };\n              case 53:\n                _context6.prev = 53;\n                this._saveSession(session);\n                this._notifyAllSubscribers('SIGNED_IN');\n                return _context6.abrupt(\"return\", {\n                  session: session,\n                  error: null\n                });\n              case 59:\n                _context6.prev = 59;\n                _context6.t1 = _context6[\"catch\"](53);\n                return _context6.abrupt(\"return\", {\n                  error: _context6.t1,\n                  session: null\n                });\n              case 62:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[21, 25], [53, 59]]);\n      }));\n    }\n    /**\n     * Overrides the JWT on the current client. The JWT will then be sent in all subsequent network requests.\n     * @param access_token a jwt access token\n     */\n  }, {\n    key: \"setAuth\",\n    value: function setAuth(access_token) {\n      this.currentSession = Object.assign(Object.assign({}, this.currentSession), {\n        access_token: access_token,\n        token_type: 'bearer',\n        user: this.user()\n      });\n      this._notifyAllSubscribers('TOKEN_REFRESHED');\n      return this.currentSession;\n    }\n    /**\n     * Gets the session data from a URL string\n     * @param options.storeSession Optionally store the session in the browser\n     */\n  }, {\n    key: \"getSessionFromUrl\",\n    value: function getSessionFromUrl(options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var error_description, provider_token, provider_refresh_token, access_token, expires_in, refresh_token, token_type, timeNow, expires_at, _yield$this$api$getUs2, user, error, session, recoveryMode;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.prev = 0;\n                if (isBrowser()) {\n                  _context7.next = 3;\n                  break;\n                }\n                throw new Error('No browser detected.');\n              case 3:\n                error_description = getParameterByName('error_description');\n                if (!error_description) {\n                  _context7.next = 6;\n                  break;\n                }\n                throw new Error(error_description);\n              case 6:\n                provider_token = getParameterByName('provider_token');\n                provider_refresh_token = getParameterByName('provider_refresh_token');\n                access_token = getParameterByName('access_token');\n                if (access_token) {\n                  _context7.next = 11;\n                  break;\n                }\n                throw new Error('No access_token detected.');\n              case 11:\n                expires_in = getParameterByName('expires_in');\n                if (expires_in) {\n                  _context7.next = 14;\n                  break;\n                }\n                throw new Error('No expires_in detected.');\n              case 14:\n                refresh_token = getParameterByName('refresh_token');\n                if (refresh_token) {\n                  _context7.next = 17;\n                  break;\n                }\n                throw new Error('No refresh_token detected.');\n              case 17:\n                token_type = getParameterByName('token_type');\n                if (token_type) {\n                  _context7.next = 20;\n                  break;\n                }\n                throw new Error('No token_type detected.');\n              case 20:\n                timeNow = Math.round(Date.now() / 1000);\n                expires_at = timeNow + parseInt(expires_in);\n                _context7.next = 24;\n                return this.api.getUser(access_token);\n              case 24:\n                _yield$this$api$getUs2 = _context7.sent;\n                user = _yield$this$api$getUs2.user;\n                error = _yield$this$api$getUs2.error;\n                if (!error) {\n                  _context7.next = 29;\n                  break;\n                }\n                throw error;\n              case 29:\n                session = {\n                  provider_token: provider_token,\n                  provider_refresh_token: provider_refresh_token,\n                  access_token: access_token,\n                  expires_in: parseInt(expires_in),\n                  expires_at: expires_at,\n                  refresh_token: refresh_token,\n                  token_type: token_type,\n                  user: user\n                };\n                if (options === null || options === void 0 ? void 0 : options.storeSession) {\n                  this._saveSession(session);\n                  recoveryMode = getParameterByName('type');\n                  this._notifyAllSubscribers('SIGNED_IN');\n                  if (recoveryMode === 'recovery') {\n                    this._notifyAllSubscribers('PASSWORD_RECOVERY');\n                  }\n                }\n                // Remove tokens from URL\n                window.location.hash = '';\n                return _context7.abrupt(\"return\", {\n                  data: session,\n                  error: null\n                });\n              case 35:\n                _context7.prev = 35;\n                _context7.t0 = _context7[\"catch\"](0);\n                return _context7.abrupt(\"return\", {\n                  data: null,\n                  error: _context7.t0\n                });\n              case 38:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[0, 35]]);\n      }));\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n     * and log them out - removing all items from localstorage and then trigger a \"SIGNED_OUT\" event.\n     *\n     * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`. There is no way to revoke a user's session JWT before it automatically expires\n     */\n  }, {\n    key: \"signOut\",\n    value: function signOut() {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var accessToken, _yield$this$api$signO, error;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                accessToken = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token;\n                this._removeSession();\n                this._notifyAllSubscribers('SIGNED_OUT');\n                if (!accessToken) {\n                  _context8.next = 10;\n                  break;\n                }\n                _context8.next = 6;\n                return this.api.signOut(accessToken);\n              case 6:\n                _yield$this$api$signO = _context8.sent;\n                error = _yield$this$api$signO.error;\n                if (!error) {\n                  _context8.next = 10;\n                  break;\n                }\n                return _context8.abrupt(\"return\", {\n                  error: error\n                });\n              case 10:\n                return _context8.abrupt(\"return\", {\n                  error: null\n                });\n              case 11:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n    }\n    /**\n     * Receive a notification every time an auth event happens.\n     * @returns {Subscription} A subscription object which can be used to unsubscribe itself.\n     */\n  }, {\n    key: \"onAuthStateChange\",\n    value: function onAuthStateChange(callback) {\n      var _this = this;\n      try {\n        var id = uuid();\n        var subscription = {\n          id: id,\n          callback: callback,\n          unsubscribe: function unsubscribe() {\n            _this.stateChangeEmitters.delete(id);\n          }\n        };\n        this.stateChangeEmitters.set(id, subscription);\n        return {\n          data: subscription,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    }\n  }, {\n    key: \"_handleEmailSignIn\",\n    value: function _handleEmailSignIn(email, password) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var _a, _b;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var _yield$this$api$signI, data, error;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.prev = 0;\n                _context9.next = 3;\n                return this.api.signInWithEmail(email, password, {\n                  redirectTo: options.redirectTo,\n                  captchaToken: options.captchaToken\n                });\n              case 3:\n                _yield$this$api$signI = _context9.sent;\n                data = _yield$this$api$signI.data;\n                error = _yield$this$api$signI.error;\n                if (!(error || !data)) {\n                  _context9.next = 8;\n                  break;\n                }\n                return _context9.abrupt(\"return\", {\n                  data: null,\n                  user: null,\n                  session: null,\n                  error: error\n                });\n              case 8:\n                if (((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.confirmed_at) || ((_b = data === null || data === void 0 ? void 0 : data.user) === null || _b === void 0 ? void 0 : _b.email_confirmed_at)) {\n                  this._saveSession(data);\n                  this._notifyAllSubscribers('SIGNED_IN');\n                }\n                return _context9.abrupt(\"return\", {\n                  data: data,\n                  user: data.user,\n                  session: data,\n                  error: null\n                });\n              case 12:\n                _context9.prev = 12;\n                _context9.t0 = _context9[\"catch\"](0);\n                return _context9.abrupt(\"return\", {\n                  data: null,\n                  user: null,\n                  session: null,\n                  error: _context9.t0\n                });\n              case 15:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[0, 12]]);\n      }));\n    }\n  }, {\n    key: \"_handlePhoneSignIn\",\n    value: function _handlePhoneSignIn(phone, password) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var _yield$this$api$signI2, data, error;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.prev = 0;\n                _context10.next = 3;\n                return this.api.signInWithPhone(phone, password, options);\n              case 3:\n                _yield$this$api$signI2 = _context10.sent;\n                data = _yield$this$api$signI2.data;\n                error = _yield$this$api$signI2.error;\n                if (!(error || !data)) {\n                  _context10.next = 8;\n                  break;\n                }\n                return _context10.abrupt(\"return\", {\n                  data: null,\n                  user: null,\n                  session: null,\n                  error: error\n                });\n              case 8:\n                if ((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.phone_confirmed_at) {\n                  this._saveSession(data);\n                  this._notifyAllSubscribers('SIGNED_IN');\n                }\n                return _context10.abrupt(\"return\", {\n                  data: data,\n                  user: data.user,\n                  session: data,\n                  error: null\n                });\n              case 12:\n                _context10.prev = 12;\n                _context10.t0 = _context10[\"catch\"](0);\n                return _context10.abrupt(\"return\", {\n                  data: null,\n                  user: null,\n                  session: null,\n                  error: _context10.t0\n                });\n              case 15:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[0, 12]]);\n      }));\n    }\n  }, {\n    key: \"_handleProviderSignIn\",\n    value: function _handleProviderSignIn(provider) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var url = this.api.getUrlForProvider(provider, {\n        redirectTo: options.redirectTo,\n        scopes: options.scopes,\n        queryParams: options.queryParams\n      });\n      try {\n        // try to open on the browser\n        if (isBrowser()) {\n          window.location.href = url;\n        }\n        return {\n          provider: provider,\n          url: url,\n          data: null,\n          session: null,\n          user: null,\n          error: null\n        };\n      } catch (e) {\n        // fallback to returning the URL\n        if (url) return {\n          provider: provider,\n          url: url,\n          data: null,\n          session: null,\n          user: null,\n          error: null\n        };\n        return {\n          data: null,\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    }\n  }, {\n    key: \"_handleOpenIDConnectSignIn\",\n    value: function _handleOpenIDConnectSignIn(_ref5) {\n      var id_token = _ref5.id_token,\n        nonce = _ref5.nonce,\n        client_id = _ref5.client_id,\n        issuer = _ref5.issuer,\n        provider = _ref5.provider;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var _yield$this$api$signI3, data, error;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (!(id_token && nonce && (client_id && issuer || provider))) {\n                  _context11.next = 17;\n                  break;\n                }\n                _context11.prev = 1;\n                _context11.next = 4;\n                return this.api.signInWithOpenIDConnect({\n                  id_token: id_token,\n                  nonce: nonce,\n                  client_id: client_id,\n                  issuer: issuer,\n                  provider: provider\n                });\n              case 4:\n                _yield$this$api$signI3 = _context11.sent;\n                data = _yield$this$api$signI3.data;\n                error = _yield$this$api$signI3.error;\n                if (!(error || !data)) {\n                  _context11.next = 9;\n                  break;\n                }\n                return _context11.abrupt(\"return\", {\n                  user: null,\n                  session: null,\n                  error: error\n                });\n              case 9:\n                this._saveSession(data);\n                this._notifyAllSubscribers('SIGNED_IN');\n                return _context11.abrupt(\"return\", {\n                  user: data.user,\n                  session: data,\n                  error: null\n                });\n              case 14:\n                _context11.prev = 14;\n                _context11.t0 = _context11[\"catch\"](1);\n                return _context11.abrupt(\"return\", {\n                  user: null,\n                  session: null,\n                  error: _context11.t0\n                });\n              case 17:\n                throw new Error(\"You must provide a OpenID Connect provider with your id token and nonce.\");\n              case 18:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this, [[1, 14]]);\n      }));\n    }\n    /**\n     * Attempts to get the session from LocalStorage\n     * Note: this should never be async (even for React Native), as we need it to return immediately in the constructor.\n     */\n  }, {\n    key: \"_recoverSession\",\n    value: function _recoverSession() {\n      try {\n        var data = getItemSynchronously(this.localStorage, STORAGE_KEY);\n        if (!data) return null;\n        var currentSession = data.currentSession,\n          expiresAt = data.expiresAt;\n        var timeNow = Math.round(Date.now() / 1000);\n        if (expiresAt >= timeNow + EXPIRY_MARGIN && (currentSession === null || currentSession === void 0 ? void 0 : currentSession.user)) {\n          this._saveSession(currentSession);\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n      } catch (error) {\n        console.log('error', error);\n      }\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */\n  }, {\n    key: \"_recoverAndRefresh\",\n    value: function _recoverAndRefresh() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var _this2 = this;\n        var data, currentSession, expiresAt, timeNow, _yield$this$_callRefr3, error;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.prev = 0;\n                _context12.next = 3;\n                return getItemAsync(this.localStorage, STORAGE_KEY);\n              case 3:\n                data = _context12.sent;\n                if (data) {\n                  _context12.next = 6;\n                  break;\n                }\n                return _context12.abrupt(\"return\", null);\n              case 6:\n                currentSession = data.currentSession, expiresAt = data.expiresAt;\n                timeNow = Math.round(Date.now() / 1000);\n                if (!(expiresAt < timeNow + EXPIRY_MARGIN)) {\n                  _context12.next = 29;\n                  break;\n                }\n                if (!(this.autoRefreshToken && currentSession.refresh_token)) {\n                  _context12.next = 26;\n                  break;\n                }\n                this.networkRetries++;\n                _context12.next = 13;\n                return this._callRefreshToken(currentSession.refresh_token);\n              case 13:\n                _yield$this$_callRefr3 = _context12.sent;\n                error = _yield$this$_callRefr3.error;\n                if (!error) {\n                  _context12.next = 23;\n                  break;\n                }\n                console.log(error.message);\n                if (!(error.message === NETWORK_FAILURE.ERROR_MESSAGE && this.networkRetries < NETWORK_FAILURE.MAX_RETRIES)) {\n                  _context12.next = 21;\n                  break;\n                }\n                if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n                this.refreshTokenTimer = setTimeout(function () {\n                  return _this2._recoverAndRefresh();\n                }, Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100 // exponential backoff\n                );\n                return _context12.abrupt(\"return\");\n              case 21:\n                _context12.next = 23;\n                return this._removeSession();\n              case 23:\n                this.networkRetries = 0;\n                _context12.next = 27;\n                break;\n              case 26:\n                this._removeSession();\n              case 27:\n                _context12.next = 30;\n                break;\n              case 29:\n                if (!currentSession) {\n                  console.log('Current session is missing data.');\n                  this._removeSession();\n                } else {\n                  // should be handled on _recoverSession method already\n                  // But we still need the code here to accommodate for AsyncStorage e.g. in React native\n                  this._saveSession(currentSession);\n                  this._notifyAllSubscribers('SIGNED_IN');\n                }\n              case 30:\n                _context12.next = 36;\n                break;\n              case 32:\n                _context12.prev = 32;\n                _context12.t0 = _context12[\"catch\"](0);\n                console.error(_context12.t0);\n                return _context12.abrupt(\"return\", null);\n              case 36:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this, [[0, 32]]);\n      }));\n    }\n  }, {\n    key: \"_callRefreshToken\",\n    value: function _callRefreshToken(refresh_token) {\n      var _a;\n      if (refresh_token === void 0) {\n        refresh_token = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.refresh_token;\n      }\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        var _yield$this$api$refre3, data, error;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.prev = 0;\n                if (refresh_token) {\n                  _context13.next = 3;\n                  break;\n                }\n                throw new Error('No current session.');\n              case 3:\n                _context13.next = 5;\n                return this.api.refreshAccessToken(refresh_token);\n              case 5:\n                _yield$this$api$refre3 = _context13.sent;\n                data = _yield$this$api$refre3.data;\n                error = _yield$this$api$refre3.error;\n                if (!error) {\n                  _context13.next = 10;\n                  break;\n                }\n                throw error;\n              case 10:\n                if (data) {\n                  _context13.next = 12;\n                  break;\n                }\n                throw Error('Invalid session data.');\n              case 12:\n                this._saveSession(data);\n                this._notifyAllSubscribers('TOKEN_REFRESHED');\n                this._notifyAllSubscribers('SIGNED_IN');\n                return _context13.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n              case 18:\n                _context13.prev = 18;\n                _context13.t0 = _context13[\"catch\"](0);\n                return _context13.abrupt(\"return\", {\n                  data: null,\n                  error: _context13.t0\n                });\n              case 21:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this, [[0, 18]]);\n      }));\n    }\n  }, {\n    key: \"_notifyAllSubscribers\",\n    value: function _notifyAllSubscribers(event) {\n      var _this3 = this;\n      this.stateChangeEmitters.forEach(function (x) {\n        return x.callback(event, _this3.currentSession);\n      });\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */\n  }, {\n    key: \"_saveSession\",\n    value: function _saveSession(session) {\n      this.currentSession = session;\n      this.currentUser = session.user;\n      var expiresAt = session.expires_at;\n      if (expiresAt) {\n        var timeNow = Math.round(Date.now() / 1000);\n        var expiresIn = expiresAt - timeNow;\n        var refreshDurationBeforeExpires = expiresIn > EXPIRY_MARGIN ? EXPIRY_MARGIN : 0.5;\n        this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000);\n      }\n      // Do we need any extra check before persist session\n      // access_token or user ?\n      if (this.persistSession && session.expires_at) {\n        this._persistSession(this.currentSession);\n      }\n    }\n  }, {\n    key: \"_persistSession\",\n    value: function _persistSession(currentSession) {\n      var data = {\n        currentSession: currentSession,\n        expiresAt: currentSession.expires_at\n      };\n      setItemAsync(this.localStorage, STORAGE_KEY, data);\n    }\n  }, {\n    key: \"_removeSession\",\n    value: function _removeSession() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                this.currentSession = null;\n                this.currentUser = null;\n                if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n                removeItemAsync(this.localStorage, STORAGE_KEY);\n              case 4:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n    }\n    /**\n     * Clear and re-create refresh token timer\n     * @param value time intervals in milliseconds\n     */\n  }, {\n    key: \"_startAutoRefreshToken\",\n    value: function _startAutoRefreshToken(value) {\n      var _this4 = this;\n      if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n      if (value <= 0 || !this.autoRefreshToken) return;\n      this.refreshTokenTimer = setTimeout(function () {\n        return __awaiter(_this4, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n          var _yield$this$_callRefr4, error;\n          return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n            while (1) {\n              switch (_context15.prev = _context15.next) {\n                case 0:\n                  this.networkRetries++;\n                  _context15.next = 3;\n                  return this._callRefreshToken();\n                case 3:\n                  _yield$this$_callRefr4 = _context15.sent;\n                  error = _yield$this$_callRefr4.error;\n                  if (!error) this.networkRetries = 0;\n                  if ((error === null || error === void 0 ? void 0 : error.message) === NETWORK_FAILURE.ERROR_MESSAGE && this.networkRetries < NETWORK_FAILURE.MAX_RETRIES) this._startAutoRefreshToken(Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100); // exponential backoff\n                case 7:\n                case \"end\":\n                  return _context15.stop();\n              }\n            }\n          }, _callee15, this);\n        }));\n      }, value);\n      if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref();\n    }\n    /**\n     * Listens for changes to LocalStorage and updates the current session.\n     */\n  }, {\n    key: \"_listenForMultiTabEvents\",\n    value: function _listenForMultiTabEvents() {\n      var _this5 = this;\n      if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n        return false;\n      }\n      try {\n        window === null || window === void 0 ? void 0 : window.addEventListener('storage', function (e) {\n          var _a;\n          if (e.key === STORAGE_KEY) {\n            var newSession = JSON.parse(String(e.newValue));\n            if ((_a = newSession === null || newSession === void 0 ? void 0 : newSession.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) {\n              _this5._saveSession(newSession.currentSession);\n              _this5._notifyAllSubscribers('SIGNED_IN');\n            } else {\n              _this5._removeSession();\n              _this5._notifyAllSubscribers('SIGNED_OUT');\n            }\n          }\n        });\n      } catch (error) {\n        console.error('_listenForMultiTabEvents', error);\n      }\n    }\n  }, {\n    key: \"_handleVisibilityChange\",\n    value: function _handleVisibilityChange() {\n      var _this6 = this;\n      if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n        return false;\n      }\n      try {\n        window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', function () {\n          if (document.visibilityState === 'visible') {\n            _this6._recoverAndRefresh();\n          }\n        });\n      } catch (error) {\n        console.error('_handleVisibilityChange', error);\n      }\n    }\n  }]);\n  return GoTrueClient;\n}();\nexport { GoTrueClient as default };","map":{"version":3,"names":["GoTrueApi","isBrowser","getParameterByName","uuid","setItemAsync","removeItemAsync","getItemSynchronously","getItemAsync","GOTRUE_URL","DEFAULT_HEADERS","STORAGE_KEY","EXPIRY_MARGIN","NETWORK_FAILURE","polyfillGlobalThis","DEFAULT_OPTIONS","url","autoRefreshToken","persistSession","detectSessionInUrl","multiTab","headers","decodeBase64URL","value","atob","replace","e","ReferenceError","Buffer","from","toString","GoTrueClient","options","_classCallCheck","stateChangeEmitters","Map","networkRetries","settings","Object","assign","currentUser","currentSession","localStorage","globalThis","api","cookieOptions","fetch","_recoverSession","_recoverAndRefresh","_listenForMultiTabEvents","_handleVisibilityChange","getSessionFromUrl","storeSession","then","_ref","error","Error","_createClass","key","signUp","_ref2","email","password","phone","arguments","length","undefined","_removeSession","_context","next","signUpWithPhone","data","captchaToken","t0","sent","signUpWithEmail","redirectTo","_ref3","session","user","access_token","_saveSession","_notifyAllSubscribers","id","abrupt","prev","t1","stop","_callee","signIn","_ref4","refreshToken","provider","oidc","_context2","sendMagicLinkEmail","shouldCreateUser","_yield$this$api$sendM","_handleEmailSignIn","sendMobileOTP","_yield$this$api$sendM2","_handlePhoneSignIn","_callRefreshToken","_yield$this$_callRefr","_handleProviderSignIn","scopes","queryParams","_handleOpenIDConnectSignIn","_callee2","verifyOTP","params","_context3","_yield$this$api$verif","_callee3","refreshSession","_a","_context4","_yield$this$_callRefr2","_callee4","update","attributes","_context5","updateUser","_yield$this$api$updat","_callee5","setSession","arg0","_context6","refresh_token","refreshAccessToken","_yield$this$api$refre","timeNow","Math","round","Date","now","expires_at","expires_in","tokenParts","split","bodyJSON","parsed","JSON","parse","exp","_yield$this$api$refre2","getUser","_yield$this$api$getUs","token_type","_callee6","setAuth","_context7","error_description","provider_token","provider_refresh_token","parseInt","_yield$this$api$getUs2","recoveryMode","window","location","hash","_callee7","signOut","accessToken","_context8","_yield$this$api$signO","_callee8","onAuthStateChange","callback","_this","subscription","unsubscribe","delete","set","signInWithEmail","_yield$this$api$signI","_context9","confirmed_at","_b","email_confirmed_at","_callee9","signInWithPhone","_yield$this$api$signI2","_context10","phone_confirmed_at","_callee10","getUrlForProvider","href","_ref5","id_token","nonce","client_id","issuer","_context11","signInWithOpenIDConnect","_yield$this$api$signI3","_callee11","expiresAt","console","log","_context12","_yield$this$_callRefr3","message","ERROR_MESSAGE","MAX_RETRIES","refreshTokenTimer","clearTimeout","setTimeout","_this2","pow","RETRY_INTERVAL","_callee12","_context13","_yield$this$api$refre3","_callee13","event","_this3","forEach","x","expiresIn","refreshDurationBeforeExpires","_startAutoRefreshToken","_persistSession","_context14","_callee14","_this4","__awaiter","_regeneratorRuntime","mark","_callee15","_yield$this$_callRefr4","wrap","_callee15$","_context15","unref","_this5","addEventListener","newSession","String","newValue","_this6","document","visibilityState","default"],"sources":["/Users/mako/Downloads/todo_supabase/node_modules/@supabase/gotrue-js/src/GoTrueClient.ts"],"sourcesContent":["import GoTrueApi from './GoTrueApi'\nimport {\n  isBrowser,\n  getParameterByName,\n  uuid,\n  setItemAsync,\n  removeItemAsync,\n  getItemSynchronously,\n  getItemAsync,\n} from './lib/helpers'\nimport {\n  GOTRUE_URL,\n  DEFAULT_HEADERS,\n  STORAGE_KEY,\n  EXPIRY_MARGIN,\n  NETWORK_FAILURE,\n} from './lib/constants'\nimport { polyfillGlobalThis } from './lib/polyfills'\nimport { Fetch } from './lib/fetch'\n\nimport type {\n  ApiError,\n  Session,\n  User,\n  UserAttributes,\n  Provider,\n  Subscription,\n  AuthChangeEvent,\n  CookieOptions,\n  UserCredentials,\n  VerifyOTPParams,\n  OpenIDConnectCredentials,\n  SupportedStorage,\n} from './lib/types'\n\npolyfillGlobalThis() // Make \"globalThis\" available\n\nconst DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  multiTab: true,\n  headers: DEFAULT_HEADERS,\n}\n\nconst decodeBase64URL = (value: string): string => {\n  try {\n    // atob is present in all browsers and nodejs >= 16\n    // but if it is not it will throw a ReferenceError in which case we can try to use Buffer\n    // replace are here to convert the Base64-URL into Base64 which is what atob supports\n    // replace with //g regex acts like replaceAll\n    return atob(value.replace(/[-]/g, '+').replace(/[_]/g, '/'))\n  } catch (e) {\n    if (e instanceof ReferenceError) {\n      // running on nodejs < 16\n      // Buffer supports Base64-URL transparently\n      return Buffer.from(value, 'base64').toString('utf-8')\n    } else {\n      throw e\n    }\n  }\n}\n\nexport default class GoTrueClient {\n  /**\n   * Namespace for the GoTrue API methods.\n   * These can be used for example to get a user from a JWT in a server environment or reset a user's password.\n   */\n  api: GoTrueApi\n  /**\n   * The currently logged in user or null.\n   */\n  protected currentUser: User | null\n  /**\n   * The session object for the currently logged in user or null.\n   */\n  protected currentSession: Session | null\n\n  protected autoRefreshToken: boolean\n  protected persistSession: boolean\n  protected localStorage: SupportedStorage\n  protected multiTab: boolean\n  protected stateChangeEmitters: Map<string, Subscription> = new Map()\n  protected refreshTokenTimer?: ReturnType<typeof setTimeout>\n  protected networkRetries: number = 0\n\n  /**\n   * Create a new client for use in the browser.\n   * @param options.url The URL of the GoTrue server.\n   * @param options.headers Any additional headers to send to the GoTrue server.\n   * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.localStorage Provide your own local storage implementation to use instead of the browser's local storage.\n   * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n   * @param options.cookieOptions\n   * @param options.fetch A custom fetch implementation.\n   */\n  constructor(options: {\n    url?: string\n    headers?: { [key: string]: string }\n    detectSessionInUrl?: boolean\n    autoRefreshToken?: boolean\n    persistSession?: boolean\n    localStorage?: SupportedStorage\n    multiTab?: boolean\n    cookieOptions?: CookieOptions\n    fetch?: Fetch\n  }) {\n    const settings = { ...DEFAULT_OPTIONS, ...options }\n    this.currentUser = null\n    this.currentSession = null\n    this.autoRefreshToken = settings.autoRefreshToken\n    this.persistSession = settings.persistSession\n    this.multiTab = settings.multiTab\n    this.localStorage = settings.localStorage || globalThis.localStorage\n    this.api = new GoTrueApi({\n      url: settings.url,\n      headers: settings.headers,\n      cookieOptions: settings.cookieOptions,\n      fetch: settings.fetch,\n    })\n    this._recoverSession()\n    this._recoverAndRefresh()\n    this._listenForMultiTabEvents()\n    this._handleVisibilityChange()\n\n    if (settings.detectSessionInUrl && isBrowser() && !!getParameterByName('access_token')) {\n      // Handle the OAuth redirect\n      this.getSessionFromUrl({ storeSession: true }).then(({ error }) => {\n        if (error) {\n          throw new Error('Error getting session from URL.')\n        }\n      })\n    }\n  }\n\n  /**\n   * Creates a new user.\n   * @type UserCredentials\n   * @param email The user's email address.\n   * @param password The user's password.\n   * @param phone The user's phone number.\n   * @param redirectTo The redirect URL attached to the signup confirmation link. Does not redirect the user if it's a mobile signup.\n   * @param data Optional user metadata.\n   */\n  async signUp(\n    { email, password, phone }: UserCredentials,\n    options: {\n      redirectTo?: string\n      data?: object\n      captchaToken?: string\n    } = {}\n  ): Promise<{\n    user: User | null\n    session: Session | null\n    error: ApiError | null\n  }> {\n    try {\n      this._removeSession()\n\n      const { data, error } =\n        phone && password\n          ? await this.api.signUpWithPhone(phone!, password!, {\n              data: options.data,\n              captchaToken: options.captchaToken,\n            })\n          : await this.api.signUpWithEmail(email!, password!, {\n              redirectTo: options.redirectTo,\n              data: options.data,\n              captchaToken: options.captchaToken,\n            })\n\n      if (error) {\n        throw error\n      }\n\n      if (!data) {\n        throw 'An error occurred on sign up.'\n      }\n\n      let session: Session | null = null\n      let user: User | null = null\n\n      if ((data as Session).access_token) {\n        session = data as Session\n        user = session.user as User\n        this._saveSession(session)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n\n      if ((data as User).id) {\n        user = data as User\n      }\n\n      return { user, session, error: null }\n    } catch (e) {\n      return { user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Log in an existing user, or login via a third-party provider.\n   * @type UserCredentials\n   * @param email The user's email address.\n   * @param phone The user's phone number.\n   * @param password The user's password.\n   * @param refreshToken A valid refresh token that was returned on login.\n   * @param provider One of the providers supported by GoTrue.\n   * @param redirectTo A URL to send the user to after they are confirmed (OAuth logins only).\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   * @param scopes A space-separated list of scopes granted to the OAuth application.\n   */\n  async signIn(\n    { email, phone, password, refreshToken, provider, oidc }: UserCredentials,\n    options: {\n      redirectTo?: string\n      shouldCreateUser?: boolean\n      scopes?: string\n      captchaToken?: string\n      queryParams?: { [key: string]: string }\n    } = {}\n  ): Promise<{\n    session: Session | null\n    user: User | null\n    provider?: Provider\n    url?: string | null\n    error: ApiError | null\n  }> {\n    try {\n      this._removeSession()\n\n      if (email && !password) {\n        const { error } = await this.api.sendMagicLinkEmail(email, {\n          redirectTo: options.redirectTo,\n          shouldCreateUser: options.shouldCreateUser,\n          captchaToken: options.captchaToken,\n        })\n        return { user: null, session: null, error }\n      }\n      if (email && password) {\n        return this._handleEmailSignIn(email, password, {\n          redirectTo: options.redirectTo,\n          captchaToken: options.captchaToken,\n        })\n      }\n      if (phone && !password) {\n        const { error } = await this.api.sendMobileOTP(phone, {\n          shouldCreateUser: options.shouldCreateUser,\n          captchaToken: options.captchaToken,\n        })\n        return { user: null, session: null, error }\n      }\n      if (phone && password) {\n        return this._handlePhoneSignIn(phone, password)\n      }\n      if (refreshToken) {\n        // currentSession and currentUser will be updated to latest on _callRefreshToken using the passed refreshToken\n        const { error } = await this._callRefreshToken(refreshToken)\n        if (error) throw error\n\n        return {\n          user: this.currentUser,\n          session: this.currentSession,\n          error: null,\n        }\n      }\n      if (provider) {\n        return this._handleProviderSignIn(provider, {\n          redirectTo: options.redirectTo,\n          scopes: options.scopes,\n          queryParams: options.queryParams,\n        })\n      }\n      if (oidc) {\n        return this._handleOpenIDConnectSignIn(oidc)\n      }\n      throw new Error(\n        `You must provide either an email, phone number, a third-party provider or OpenID Connect.`\n      )\n    } catch (e) {\n      return { user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Log in a user given a User supplied OTP received via mobile.\n   * @param email The user's email address.\n   * @param phone The user's phone number.\n   * @param token The user's password.\n   * @param type The user's verification type.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  async verifyOTP(\n    params: VerifyOTPParams,\n    options: {\n      redirectTo?: string\n    } = {}\n  ): Promise<{\n    user: User | null\n    session: Session | null\n    error: ApiError | null\n  }> {\n    try {\n      this._removeSession()\n\n      const { data, error } = await this.api.verifyOTP(params, options)\n\n      if (error) {\n        throw error\n      }\n\n      if (!data) {\n        throw 'An error occurred on token verification.'\n      }\n\n      let session: Session | null = null\n      let user: User | null = null\n\n      if ((data as Session).access_token) {\n        session = data as Session\n        user = session.user as User\n        this._saveSession(session)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n\n      if ((data as User).id) {\n        user = data as User\n      }\n\n      return { user, session, error: null }\n    } catch (e) {\n      return { user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Inside a browser context, `user()` will return the user data, if there is a logged in user.\n   *\n   * For server-side management, you can get a user through `auth.api.getUserByCookie()`\n   */\n  user(): User | null {\n    return this.currentUser\n  }\n\n  /**\n   * Returns the session data, if there is an active session.\n   */\n  session(): Session | null {\n    return this.currentSession\n  }\n\n  /**\n   * Force refreshes the session including the user data in case it was updated in a different session.\n   */\n  async refreshSession(): Promise<{\n    data: Session | null\n    user: User | null\n    error: ApiError | null\n  }> {\n    try {\n      if (!this.currentSession?.access_token) throw new Error('Not logged in.')\n\n      // currentSession and currentUser will be updated to latest on _callRefreshToken\n      const { error } = await this._callRefreshToken()\n      if (error) throw error\n\n      return { data: this.currentSession, user: this.currentUser, error: null }\n    } catch (e) {\n      return { data: null, user: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Updates user data, if there is a logged in user.\n   */\n  async update(\n    attributes: UserAttributes\n  ): Promise<{ data: User | null; user: User | null; error: ApiError | null }> {\n    try {\n      if (!this.currentSession?.access_token) throw new Error('Not logged in.')\n\n      const { user, error } = await this.api.updateUser(\n        this.currentSession.access_token,\n        attributes\n      )\n      if (error) throw error\n      if (!user) throw Error('Invalid user data.')\n\n      const session = { ...this.currentSession, user }\n      this._saveSession(session)\n      this._notifyAllSubscribers('USER_UPDATED')\n\n      return { data: user, user, error: null }\n    } catch (e) {\n      return { data: null, user: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sets the session from the provided session information. The access_token\n   * is reused if it is not expired, otherwise a new access token is fetched by\n   * refreshing the session with the provided refresh_token.\n   *\n   * This method is useful when using in a server-side rendered context.\n   *\n   * @param params.refresh_token A valid refresh token (typically obtained from a cookie)\n   * @param params.access_token An access token (typically obtained from a cookie)\n   */\n  async setSession(params: {\n    refresh_token: string\n    access_token: string\n  }): Promise<{ session: Session | null; error: ApiError | null }>\n\n  /**\n   * Sets the session data from refresh_token and returns current Session and Error\n   * @param refresh_token a JWT token\n   */\n  async setSession(\n    refresh_token: string\n  ): Promise<{ session: Session | null; error: ApiError | null }>\n\n  async setSession(\n    arg0: string | { access_token: string; refresh_token: string }\n  ): Promise<{ session: Session | null; error: ApiError | null }> {\n    let session: Session\n\n    if (typeof arg0 === 'string') {\n      // using the refresh_token string API\n      const refresh_token = arg0\n\n      const { data, error } = await this.api.refreshAccessToken(refresh_token)\n      if (error) {\n        return { session: null, error: error }\n      }\n\n      session = data!\n    } else {\n      // using the object parameter API\n\n      const timeNow = Math.round(Date.now() / 1000)\n\n      let { refresh_token, access_token } = arg0\n      let expires_at = 0\n      let expires_in = 0\n\n      const tokenParts = access_token.split('.')\n      if (tokenParts.length !== 3) throw new Error('access_token is not a proper JWT')\n\n      const bodyJSON = decodeBase64URL(tokenParts[1])\n\n      let parsed: any = undefined\n      try {\n        parsed = JSON.parse(bodyJSON)\n      } catch (e) {\n        throw new Error('access_token is not a proper JWT, invalid JSON in body')\n      }\n\n      if (typeof parsed === 'object' && parsed && typeof parsed.exp === 'number') {\n        expires_at = parsed.exp\n        expires_in = timeNow - parsed.exp\n      } else {\n        throw new Error('access_token is not a proper JWT, missing exp claim')\n      }\n\n      if (timeNow > expires_at) {\n        const { data, error } = await this.api.refreshAccessToken(refresh_token)\n        if (error) {\n          return { session: null, error: error }\n        }\n\n        session = data!\n      } else {\n        const { user, error } = await this.api.getUser(access_token)\n        if (error) throw error\n\n        session = {\n          access_token,\n          expires_in,\n          expires_at,\n          refresh_token,\n          token_type: 'bearer',\n          user: user!,\n        }\n      }\n    }\n\n    try {\n      this._saveSession(session)\n      this._notifyAllSubscribers('SIGNED_IN')\n      return { session, error: null }\n    } catch (e) {\n      return { error: e as ApiError, session: null }\n    }\n  }\n\n  /**\n   * Overrides the JWT on the current client. The JWT will then be sent in all subsequent network requests.\n   * @param access_token a jwt access token\n   */\n  setAuth(access_token: string): Session {\n    this.currentSession = {\n      ...this.currentSession,\n      access_token,\n      token_type: 'bearer',\n      user: this.user(),\n    }\n\n    this._notifyAllSubscribers('TOKEN_REFRESHED')\n\n    return this.currentSession\n  }\n\n  /**\n   * Gets the session data from a URL string\n   * @param options.storeSession Optionally store the session in the browser\n   */\n  async getSessionFromUrl(options?: {\n    storeSession?: boolean\n  }): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      if (!isBrowser()) throw new Error('No browser detected.')\n\n      const error_description = getParameterByName('error_description')\n      if (error_description) throw new Error(error_description)\n\n      const provider_token = getParameterByName('provider_token')\n      const provider_refresh_token = getParameterByName('provider_refresh_token')\n      const access_token = getParameterByName('access_token')\n      if (!access_token) throw new Error('No access_token detected.')\n      const expires_in = getParameterByName('expires_in')\n      if (!expires_in) throw new Error('No expires_in detected.')\n      const refresh_token = getParameterByName('refresh_token')\n      if (!refresh_token) throw new Error('No refresh_token detected.')\n      const token_type = getParameterByName('token_type')\n      if (!token_type) throw new Error('No token_type detected.')\n\n      const timeNow = Math.round(Date.now() / 1000)\n      const expires_at = timeNow + parseInt(expires_in)\n\n      const { user, error } = await this.api.getUser(access_token)\n      if (error) throw error\n\n      const session: Session = {\n        provider_token,\n        provider_refresh_token,\n        access_token,\n        expires_in: parseInt(expires_in),\n        expires_at,\n        refresh_token,\n        token_type,\n        user: user!,\n      }\n      if (options?.storeSession) {\n        this._saveSession(session)\n        const recoveryMode = getParameterByName('type')\n        this._notifyAllSubscribers('SIGNED_IN')\n        if (recoveryMode === 'recovery') {\n          this._notifyAllSubscribers('PASSWORD_RECOVERY')\n        }\n      }\n      // Remove tokens from URL\n      window.location.hash = ''\n\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n   * and log them out - removing all items from localstorage and then trigger a \"SIGNED_OUT\" event.\n   *\n   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`. There is no way to revoke a user's session JWT before it automatically expires\n   */\n  async signOut(): Promise<{ error: ApiError | null }> {\n    const accessToken = this.currentSession?.access_token\n    this._removeSession()\n    this._notifyAllSubscribers('SIGNED_OUT')\n    if (accessToken) {\n      const { error } = await this.api.signOut(accessToken)\n      if (error) return { error }\n    }\n    return { error: null }\n  }\n\n  /**\n   * Receive a notification every time an auth event happens.\n   * @returns {Subscription} A subscription object which can be used to unsubscribe itself.\n   */\n  onAuthStateChange(callback: (event: AuthChangeEvent, session: Session | null) => void): {\n    data: Subscription | null\n    error: ApiError | null\n  } {\n    try {\n      const id: string = uuid()\n      const subscription: Subscription = {\n        id,\n        callback,\n        unsubscribe: () => {\n          this.stateChangeEmitters.delete(id)\n        },\n      }\n      this.stateChangeEmitters.set(id, subscription)\n      return { data: subscription, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  private async _handleEmailSignIn(\n    email: string,\n    password: string,\n    options: {\n      redirectTo?: string\n      captchaToken?: string\n    } = {}\n  ) {\n    try {\n      const { data, error } = await this.api.signInWithEmail(email, password, {\n        redirectTo: options.redirectTo,\n        captchaToken: options.captchaToken,\n      })\n      if (error || !data) return { data: null, user: null, session: null, error }\n\n      if (data?.user?.confirmed_at || data?.user?.email_confirmed_at) {\n        this._saveSession(data)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n\n      return { data, user: data.user, session: data, error: null }\n    } catch (e) {\n      return { data: null, user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  private async _handlePhoneSignIn(\n    phone: string,\n    password: string,\n    options: {\n      captchaToken?: string\n    } = {}\n  ) {\n    try {\n      const { data, error } = await this.api.signInWithPhone(phone, password, options)\n      if (error || !data) return { data: null, user: null, session: null, error }\n\n      if (data?.user?.phone_confirmed_at) {\n        this._saveSession(data)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n\n      return { data, user: data.user, session: data, error: null }\n    } catch (e) {\n      return { data: null, user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  private _handleProviderSignIn(\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n      queryParams?: { [key: string]: string }\n    } = {}\n  ) {\n    const url: string = this.api.getUrlForProvider(provider, {\n      redirectTo: options.redirectTo,\n      scopes: options.scopes,\n      queryParams: options.queryParams,\n    })\n\n    try {\n      // try to open on the browser\n      if (isBrowser()) {\n        window.location.href = url\n      }\n      return { provider, url, data: null, session: null, user: null, error: null }\n    } catch (e) {\n      // fallback to returning the URL\n      if (url) return { provider, url, data: null, session: null, user: null, error: null }\n      return { data: null, user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  private async _handleOpenIDConnectSignIn({\n    id_token,\n    nonce,\n    client_id,\n    issuer,\n    provider,\n  }: OpenIDConnectCredentials): Promise<{\n    session: Session | null\n    user: User | null\n    error: ApiError | null\n  }> {\n    if (id_token && nonce && ((client_id && issuer) || provider)) {\n      try {\n        const { data, error } = await this.api.signInWithOpenIDConnect({\n          id_token,\n          nonce,\n          client_id,\n          issuer,\n          provider,\n        })\n        if (error || !data) return { user: null, session: null, error }\n        this._saveSession(data)\n        this._notifyAllSubscribers('SIGNED_IN')\n        return { user: data.user, session: data, error: null }\n      } catch (e) {\n        return { user: null, session: null, error: e as ApiError }\n      }\n    }\n    throw new Error(`You must provide a OpenID Connect provider with your id token and nonce.`)\n  }\n\n  /**\n   * Attempts to get the session from LocalStorage\n   * Note: this should never be async (even for React Native), as we need it to return immediately in the constructor.\n   */\n  private _recoverSession() {\n    try {\n      const data = getItemSynchronously(this.localStorage, STORAGE_KEY)\n      if (!data) return null\n      const { currentSession, expiresAt } = data\n      const timeNow = Math.round(Date.now() / 1000)\n\n      if (expiresAt >= timeNow + EXPIRY_MARGIN && currentSession?.user) {\n        this._saveSession(currentSession)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n    } catch (error) {\n      console.log('error', error)\n    }\n  }\n\n  /**\n   * Recovers the session from LocalStorage and refreshes\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n   */\n  private async _recoverAndRefresh() {\n    try {\n      const data = await getItemAsync(this.localStorage, STORAGE_KEY)\n      if (!data) return null\n      const { currentSession, expiresAt } = data\n      const timeNow = Math.round(Date.now() / 1000)\n\n      if (expiresAt < timeNow + EXPIRY_MARGIN) {\n        if (this.autoRefreshToken && currentSession.refresh_token) {\n          this.networkRetries++\n          const { error } = await this._callRefreshToken(currentSession.refresh_token)\n          if (error) {\n            console.log(error.message)\n            if (\n              error.message === NETWORK_FAILURE.ERROR_MESSAGE &&\n              this.networkRetries < NETWORK_FAILURE.MAX_RETRIES\n            ) {\n              if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer)\n              this.refreshTokenTimer = setTimeout(\n                () => this._recoverAndRefresh(),\n                NETWORK_FAILURE.RETRY_INTERVAL ** this.networkRetries * 100 // exponential backoff\n              )\n              return\n            }\n            await this._removeSession()\n          }\n          this.networkRetries = 0\n        } else {\n          this._removeSession()\n        }\n      } else if (!currentSession) {\n        console.log('Current session is missing data.')\n        this._removeSession()\n      } else {\n        // should be handled on _recoverSession method already\n        // But we still need the code here to accommodate for AsyncStorage e.g. in React native\n        this._saveSession(currentSession)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n    } catch (err) {\n      console.error(err)\n      return null\n    }\n  }\n\n  private async _callRefreshToken(refresh_token = this.currentSession?.refresh_token) {\n    try {\n      if (!refresh_token) {\n        throw new Error('No current session.')\n      }\n      const { data, error } = await this.api.refreshAccessToken(refresh_token)\n      if (error) throw error\n      if (!data) throw Error('Invalid session data.')\n\n      this._saveSession(data)\n      this._notifyAllSubscribers('TOKEN_REFRESHED')\n      this._notifyAllSubscribers('SIGNED_IN')\n\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  private _notifyAllSubscribers(event: AuthChangeEvent) {\n    this.stateChangeEmitters.forEach((x) => x.callback(event, this.currentSession))\n  }\n\n  /**\n   * set currentSession and currentUser\n   * process to _startAutoRefreshToken if possible\n   */\n  private _saveSession(session: Session) {\n    this.currentSession = session\n    this.currentUser = session.user\n\n    const expiresAt = session.expires_at\n    if (expiresAt) {\n      const timeNow = Math.round(Date.now() / 1000)\n      const expiresIn = expiresAt - timeNow\n      const refreshDurationBeforeExpires = expiresIn > EXPIRY_MARGIN ? EXPIRY_MARGIN : 0.5\n      this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000)\n    }\n\n    // Do we need any extra check before persist session\n    // access_token or user ?\n    if (this.persistSession && session.expires_at) {\n      this._persistSession(this.currentSession)\n    }\n  }\n\n  private _persistSession(currentSession: Session) {\n    const data = { currentSession, expiresAt: currentSession.expires_at }\n    setItemAsync(this.localStorage, STORAGE_KEY, data)\n  }\n\n  private async _removeSession() {\n    this.currentSession = null\n    this.currentUser = null\n    if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer)\n    removeItemAsync(this.localStorage, STORAGE_KEY)\n  }\n\n  /**\n   * Clear and re-create refresh token timer\n   * @param value time intervals in milliseconds\n   */\n  private _startAutoRefreshToken(value: number) {\n    if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer)\n    if (value <= 0 || !this.autoRefreshToken) return\n\n    this.refreshTokenTimer = setTimeout(async () => {\n      this.networkRetries++\n      const { error } = await this._callRefreshToken()\n      if (!error) this.networkRetries = 0\n      if (\n        error?.message === NETWORK_FAILURE.ERROR_MESSAGE &&\n        this.networkRetries < NETWORK_FAILURE.MAX_RETRIES\n      )\n        this._startAutoRefreshToken(NETWORK_FAILURE.RETRY_INTERVAL ** this.networkRetries * 100) // exponential backoff\n    }, value)\n    if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref()\n  }\n\n  /**\n   * Listens for changes to LocalStorage and updates the current session.\n   */\n  private _listenForMultiTabEvents() {\n    if (!this.multiTab || !isBrowser() || !window?.addEventListener) {\n      return false\n    }\n\n    try {\n      window?.addEventListener('storage', (e: StorageEvent) => {\n        if (e.key === STORAGE_KEY) {\n          const newSession = JSON.parse(String(e.newValue))\n          if (newSession?.currentSession?.access_token) {\n            this._saveSession(newSession.currentSession)\n            this._notifyAllSubscribers('SIGNED_IN')\n          } else {\n            this._removeSession()\n            this._notifyAllSubscribers('SIGNED_OUT')\n          }\n        }\n      })\n    } catch (error) {\n      console.error('_listenForMultiTabEvents', error)\n    }\n  }\n\n  private _handleVisibilityChange() {\n    if (!this.multiTab || !isBrowser() || !window?.addEventListener) {\n      return false\n    }\n\n    try {\n      window?.addEventListener('visibilitychange', () => {\n        if (document.visibilityState === 'visible') {\n          this._recoverAndRefresh()\n        }\n      })\n    } catch (error) {\n      console.error('_handleVisibilityChange', error)\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}